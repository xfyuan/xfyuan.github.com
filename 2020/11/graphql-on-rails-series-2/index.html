<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<link rel="icon" href="/assets/images/logo.png">

<title>GraphQL on Rails——更新 | The Tragedy of XY</title>

<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>GraphQL on Rails——更新 | The Tragedy of XY</title>
<meta name="generator" content="Jekyll v4.1.0" />
<meta property="og:title" content="GraphQL on Rails——更新" />
<meta name="author" content="Mr.Z" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="本文已获得原作者（Dmitry Tsepelev）、（Polina Gurtovaya）和 Evil Martians 授权许可进行翻译。原文是 Rails + React 使用 GraphQL的系列教程第二篇，介绍了以 Rails 作为后端，React + Apollo 作为前端，如何进行数据更新的教学。" />
<meta property="og:description" content="本文已获得原作者（Dmitry Tsepelev）、（Polina Gurtovaya）和 Evil Martians 授权许可进行翻译。原文是 Rails + React 使用 GraphQL的系列教程第二篇，介绍了以 Rails 作为后端，React + Apollo 作为前端，如何进行数据更新的教学。" />
<meta property="og:site_name" content="The Tragedy of XY" />
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xfyuan/ossimgs@master/uPic/IMG_20201121_131305.jpg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-11-24T00:00:00+00:00" />
<script type="application/ld+json">
{"dateModified":"2020-11-24T00:00:00+00:00","datePublished":"2020-11-24T00:00:00+00:00","description":"本文已获得原作者（Dmitry Tsepelev）、（Polina Gurtovaya）和 Evil Martians 授权许可进行翻译。原文是 Rails + React 使用 GraphQL的系列教程第二篇，介绍了以 Rails 作为后端，React + Apollo 作为前端，如何进行数据更新的教学。","url":"/2020/11/graphql-on-rails-series-2/","@type":"BlogPosting","image":"https://cdn.jsdelivr.net/gh/xfyuan/ossimgs@master/uPic/IMG_20201121_131305.jpg","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"/assets/images/logo.png"},"name":"Mr.Z"},"mainEntityOfPage":{"@type":"WebPage","@id":"/2020/11/graphql-on-rails-series-2/"},"author":{"@type":"Person","name":"Mr.Z"},"headline":"GraphQL on Rails——更新","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


<link href="/assets/css/prism.css" rel="stylesheet">

<link href="/assets/css/theme.css" rel="stylesheet">

<script src="/assets/js/jquery.min.js"></script>

</head>




<body>
	<!-- defer loading of font and font awesome -->
	<noscript id="deferred-styles">
		<link href="https://fonts.googleapis.com/css?family=Sen:400,700&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	</noscript>

<!-- Begin Sidebar Navigation
================================================== -->

<div class="sidebar">
</div>
<div class="nav-icon">
    <div class="hamburger-bar"></div>
</div>
<div id="blackover-nav" class="blackover"></div>
<nav id="menu">
    <ul>
        <h3>Navigation</h3>
        <li><a href="/">Home</a></li>
        <li><a href="/categories">Categories</a></li>
        <li><a href="/about">About</a></li>
    </ul>
</nav>

<script src="/assets/js/lunr.js"></script>

<style>
    
</style>

<div class="wrap-search">
    <div class="d-flex align-items-center ml-auto">
        <i class="fas fa-search show-search"></i>
        <form class="bd-search ml-3" onSubmit="return lunr_search(document.getElementById('lunrsearch').value);">
            <input type="text" class="form-control bigradius text-small launch-modal-search" id="lunrsearch" name="q" maxlength="255" value="" placeholder="Type and enter..."/>
        </form>
    </div>
</div>

<div id="lunrsearchresults">
    <ul></ul>
</div>

<script src="/assets/js/lunrsearchengine.js"></script>


<!-- End Sidebar Navigation
================================================== -->

<div class="site-content ">

<div class="container">

    <!-- Site Logo/Name
    ================================================== -->

    <a class="navbar-brand" href="/">
        <img src="/assets/images/logo.png" alt="The Tragedy of XY">
    </a>


    <!-- Site Tag
    ================================================== -->
    

    <!-- Content
    ================================================== -->
    <div class="main-content">
        <div class="entry-header">
    <!-- Post Title -->
    <h1 class="posttitle">GraphQL on Rails——更新</h1>
    <!-- Author & Date  Box -->
    
    
    <div class="d-flex align-items-center mt-4">
        <div>
            
            <img class="author-thumb" src="/assets/images/avatar.png" alt="Mr.Z">
            
        </div>            
        <div>
        Written by <a target="_blank" class="text-dark" href="https://xfyuan.github.io">Mr.Z</a> on 
        <span class="post-date"><time class="post-date" datetime="2020-11-24">24 Nov 2020</time></span>           
        
        </div>            
    </div>
    
</div>

<!-- Adsense under title if enabled from _config.yml (change your pub id and slot) -->


<!-- Featured Image -->

<div class="entry-featured-image">
    
    <img class="featured-image lazyimg " src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAACCAQAAAA3fa6RAAAADklEQVR42mNkAANGCAUAACMAA2w/AMgAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/xfyuan/ossimgs@master/uPic/IMG_20201121_131305.jpg" alt="GraphQL on Rails——更新">
    
</div>


<!-- Content -->
<!-- Post, Page Content
================================================== -->
<div class="article-post">
    <!-- Toc if any -->
    
    <!-- End Toc -->
    <p><em>本文已获得原作者（Dmitry Tsepelev）、（Polina Gurtovaya）和 Evil Martians 授权许可进行翻译。原文是 Rails + React 使用 GraphQL的系列教程第二篇，介绍了以 Rails 作为后端，React + Apollo 作为前端，如何进行数据更新的教学。</em></p>

<ul>
  <li>原文链接：<a href="https://evilmartians.com/chronicles/graphql-on-rails-2-updating-the-data">GraphQL on Rails: Updating the data</a></li>
  <li>作者：<a href="https://twitter.com/dmitrytsepelev">Dmitry Tsepelev</a>，<a href="https://github.com/HellSquirrel">Polina Gurtovaya</a></li>
  <li>站点：Evil Martians ——位于纽约和俄罗斯的 Ruby on Rails 开发人员博客。 它发布了许多优秀的文章，并且是不少 gem 的赞助商。</li>
</ul>

<p><em>【正文如下】</em></p>

<h2 id="引言">引言</h2>

<p><strong>这是一个在后端使用 Rails、前端使用 React/Apollo 来开发 GraphQL 应用程序的旅行者指导。本教程的第二部分将涵盖 mutation（更新数据的方式）和有关客户端缓存的高级主题</strong></p>

<p>在该指南的<a href="https://evilmartians.com/chronicles/graphql-on-rails-1-from-zero-to-the-first-query">第一部分</a>中，我们学到了 GraphQL 是什么，并创建了一个 Martian Library 应用程序的很初级的版本。如果你还没阅读的话，现在正好去看一下。</p>

<p>我们已经配置了<code>graphql-ruby</code> gem 和 Apollo 框架以确保它们能一起很好地工作，也通过添加一个很初级的查询节点到 schema 上来实战检验了其配置。现在该继续前行了！</p>

<h2 id="introducing-mutations">Introducing mutations</h2>

<p>我们已经知道，在 GraphQL 中有三种基础 operation—— query，mutation，及 subscriptions。本文中，我们将介绍 mutation——一种从 GraphQL 进行数据更改的机制。</p>

<p>从客户端的角度看，mutation 看起来跟 query 很像，只有一点细微的差别——它们从“mutation”节点开始：</p>

<pre><code class="language-graphql">mutation SignInUser($email: String) {
  signIn(email: $email) {
    id
  }
}
</code></pre>

<p>然而，其主要的区别，是语义上的：首先，mutation 负责修改（或<em>转变</em>）数据。在执行引擎处理它们的方式上，也有一个差别：根据规范，GraphQL 服务端<a href="https://graphql.github.io/graphql-spec/June2018/#sec-Mutation">必须确保</a> mutation 是被连续执行的，而 query 则能被并行执行。</p>

<p>在上面的 mutation 示例中，我们通过用户的 email 向服务端请求身份验证，以如下方式：</p>

<ul>
  <li>我们以一个 operation 名<code>SignInUser</code>和一个变量<code>$email</code>（所有 GraphQL 中的变量都以<code>$</code>开头）来定义一个 mutation 开始。</li>
  <li>我们有一个想要执行修改的列表在大括号内（该列表称作 <em>selection set</em>）——这里我们只有一个叫<code>signIn</code>的字段。</li>
  <li>跟 query 一样，在根字段内我们可以有嵌套的 selection sets（即，从 mutation 返回值选择特定字段）。</li>
</ul>

<p><img src="https://cdn.evilmartians.com/front/posts/graphql-on-rails-2-updating-the-data/mutation-77c15e7.png" alt="https://cdn.evilmartians.com/front/posts/graphql-on-rails-2-updating-the-data/mutation-77c15e7.png" /></p>

<p>这些就是理论方面我们所需要了解的东西了。接下来的内容将专注于实践：我们将添加 mutation 来对用户进行身份验证，以及让用户添加新 items 到 Martian library。</p>

<h2 id="housekeeping">Housekeeping</h2>

<p>先来快速看下在前一部分教程完成后我们的成果。你可在<a href="https://github.com/evilmartians/chronicles-gql-martian-library/tree/part-1">这里</a>找到源码——别忘了在首次运行前执行<code>bundle install &amp;&amp; yarn install</code>。<a href="https://github.com/evilmartians/chronicles-gql-martian-library">Master</a> 分支则代表了该项目的当前状态。</p>

<p>我们使用<code>graphql-tag</code>库来执行查询，并使它们在同一个文件中靠近组件：</p>

<pre><code class="language-js">// app/javascript/components/Library/index.js

import React from "react";
import { Query } from "react-apollo";
import gql from "graphql-tag";

const LibraryQuery = gql`
  {
    items {
      id
      title
      user {
        email
      }
    }
  }
`;

export default () =&gt; (
  &lt;Query query={LibraryQuery}&gt;
    {({ data, loading }) =&gt; (
      &lt;div&gt;
        {loading
          ? "loading..."
          : data.items.map(({ title, id, user }) =&gt; (
              &lt;div key={id}&gt;
                &lt;b&gt;{title}&lt;/b&gt; {user ? `added by ${user.email}` : null}
              &lt;/div&gt;
            ))}
      &lt;/div&gt;
    )}
  &lt;/Query&gt;
);
</code></pre>

<p>或者，你可以把这些 operation 放在不同的文件中，以<code>.graphql</code>（或<code>.gql</code>）扩展名，保存在同一个目录下，作为组件定义。这种方案在开发中型——到大型——的应用程序时尤其有用，提供了清晰的项目结构。我们在本教程中对于所有的新 operation 都将使用它。</p>

<p>要让 Webpack “理解”<code>.gql</code>文件，我们需要在<code>/config/webpack/environment.js</code>中配置一个特别的 loader：</p>

<pre><code class="language-js">// config/webpack/environment.js
const { environment } = require("@rails/webpacker");

environment.loaders.append("graphql", {
  test: /\.(graphql|gql)$/,
  exclude: /node_modules/,
  loader: "graphql-tag/loader"
});

module.exports = environment;
</code></pre>

<p>别忘了重启来让配置生效。</p>

<p>现在已经准备好实现身份验证逻辑了。</p>

<h2 id="implementing-authentication">Implementing authentication</h2>

<p>GraphQL 规范没有告诉你如何实现身份验证逻辑，甚至不需要你有这个——这取决于开发者。然而，你很难想象一个真实的应用程序没有它，我们的 Martian Library 也不例外——我们需要一种方式来追踪所有被添加到图书馆的 items 的<em>拥有者</em>。</p>

<p>我们让事情简单些，以用户的 email 进行验证，毋需密码，短信，及其他确认方式。</p>

<p>下面是我们的身份验证机制的概览：</p>

<ul>
  <li>用户提供 email 来发起身份验证请求</li>
  <li>服务端验证该用户存在并以一个<em>身份验证 tokan</em> 返回响应</li>
  <li>用户每次后续请求都带上该 token（比如，通过 HTTP Header）以证明其身份</li>
</ul>

<p>我们将使用一个 GraphQL mutation，<code>signIn</code>，来执行身份验证，并以一个 base64 加密的 email 作为身份验证 token，以及一个“Authorization” header 来传递该 token。注意，使用 GraphQL API 来验证用户并非是必须的：其可以在“外部”完成，比如，通过 REST。这在当你仅允许已验证用户访问 GraphQL API 时特别有用。</p>

<p>我们也期望在 UI 中指示用户是否已经通过身份验证。为此，我们将添加一个 panel ，如果用户已登录则显示其名称，否则显示“Sign In”按钮：</p>

<p><img src="https://cdn.evilmartians.com/front/posts/graphql-on-rails-2-updating-the-data/user_info-af682ad.gif" alt="https://cdn.evilmartians.com/front/posts/graphql-on-rails-2-updating-the-data/user_info-af682ad.gif" /></p>

<h3 id="crafting-authentication-schema">Crafting authentication schema</h3>

<p>让我们先来添加一个 API 以获取当前用户的信息。</p>

<p>我们想让事情简单些：添加一个<code>me</code>字段到 query 的根上来返回其 context 的当前用户：</p>

<pre><code class="language-ruby"># app/graphql/types/query_type.rb

module Types
  class QueryType &lt; Types::BaseObject
    # ...
    field :me, Types::UserType, null: true

    def me
      context[:current_user]
    end
  end
end
</code></pre>

<p>如何得到<code>:current_user</code>？我们来添加一个<code>ApplicationController#current_user</code>方法，实现上述的身份验证逻辑：</p>

<pre><code class="language-ruby"># app/controllers/application_controller.rb

class ApplicationController &lt; ActionController::Base
  private

  def current_user
    token = request.headers["Authorization"].to_s
    email = Base64.decode64(token)
    User.find_by(email: email)
  end
end
</code></pre>

<p>最后，我们更新<code>GraphqlController#execute</code>方法以传递<code>current_user</code>到 context 内：</p>

<pre><code class="language-ruby"># app/controllers/graphql_controller.rb

class GraphqlController &lt; ApplicationController
  def execute
    result = MartianLibrarySchema.execute(
      params[:query],
      variables: ensure_hash(params[:variables]),
      # Only this line has chagned
      context: { current_user: current_user },
      operation_name: params[:operationName]
    )
    render json: result
  end

  # ...
end
</code></pre>

<p>漂亮！现在我们的客户端就能拿到当前用户的信息了。但不幸的是，它总是返回<code>nil</code>——我们还没有加上告知当前谁正在使用应用的方法。来修复它！</p>

<p>打开<code>Mutations::BaseMutation</code>类并粘贴如下代码（默认生成器继承自更复杂的<code>GraphQL::Schema::RelayClassicMutation</code>类）：</p>

<pre><code class="language-ruby"># app/graphql/mutations/base_mutation.rb

module Mutations
  class BaseMutation &lt; GraphQL::Schema::Mutation
  end
end
</code></pre>

<p>我们将使用这个类作为<code>SignInMutation</code>的父类：</p>

<pre><code class="language-ruby"># app/graphql/mutations/sign_in_mutation.rb

module Mutations
  class SignInMutation &lt; Mutations::BaseMutation
    argument :email, String, required: true

    field :token, String, null: true
    field :user, Types::UserType, null: true

    def resolve(email:)
      user = User.find_by!(email: email)
      return {} unless user

      token = Base64.encode64(user.email)
      {
        token: token,
        user: user
      }
    end
  end
end
</code></pre>

<p>如你所见，我们指定了 mutation 可以返回一个 token 和一个当前的用户，而唯一接收的参数是<code>email</code>。在<code>#resolve</code>方法内，我们查找用户，如果找到了，就以 base64 加密的 email 作为 token 返回，否则返回<code>null</code>。</p>

<p>第一眼看去，mutation 类就像一个常规的 Rails controller，但它有一个重要的优点：它是强类型的，通过其 schema 来验证输入的数据。</p>

<p>最后，我们需要在<code>MutationType</code>中暴露这第一个 mutation：</p>

<pre><code class="language-ruby"># app/graphql/types/mutation_type.rb

module Types
  class MutationType &lt; Types::BaseObject
    field :sign_in, mutation: Mutations::SignInMutation
  end
end
</code></pre>

<p>总结一下，为了添加一个新 mutation，你需要完成如下步骤：</p>

<ul>
  <li>添加一个类实现 mutation 逻辑，其包含：</li>
  <li>输入值的类型定义（arguments）；</li>
  <li>返回值的类型定义；</li>
  <li><code>#resolve</code>方法</li>
  <li>添加一个新的入口到<code>MutationType</code>中</li>
</ul>

<p>注意，我们根本没有提到 spec 测试：可以使用在之前编写的 query spec 所用过的相同技术来添加这里的 spec。或者去看看我们在示例代码库中写好的测试！</p>

<h3 id="adding-user-info-panel">Adding user info panel</h3>

<p>让我们暂时先忘掉 Ruby 一会，把注意力放到前端应用来。</p>

<p>由于我们的代码库在不断增长，所以需要考虑一个更好的代码组织方式。我们对于 UI 组件推荐如下结构：</p>

<ul>
  <li>每个组件存放到一个单独的目录中（比如，<code>app/javascript/components/MyComponent</code>）</li>
  <li><code>index.js</code>包含实现部分</li>
  <li>query 定义在<code>operations.graphql</code>中</li>
  <li>样式放到<code>styles.module.css</code>中（如文件名所建议的那样，我们使用<a href="https://github.com/css-modules/css-modules">css modules</a>而毋需担心样式冲突）</li>
</ul>

<p>为了避免为每个组件都手动创建这些文件的繁琐，我们写了一个<a href="https://github.com/HellSquirrel/create-gql-component">gql-component generator（graphql 组件生成器）</a>。用它来创建一个称为<code>UserInfo</code>的组件吧：</p>

<pre><code class="language-bash">$ npx @hellsquirrel/create-gql-component create app/javascript/components/UserInfo
</code></pre>

<p>注意：样式代码在本文中被去掉了，以保持简洁，但你可以在 GitHub 的 <a href="https://github.com/evilmartians/chronicles-gql-martian-library">repo</a> 中找到所有的样式文件。如果你使用我们的生成器，样式会被自动添加。</p>

<p>这将是你的文件结构看起来的样子：</p>

<p><img src="https://cdn.evilmartians.com/front/posts/graphql-on-rails-2-updating-the-data/component_structure-9a81b3c.png" alt="https://cdn.evilmartians.com/front/posts/graphql-on-rails-2-updating-the-data/component_structure-9a81b3c.png" /></p>

<p><code>UserInfo</code>组件负责“Sign In”的功能，以及当通过身份验证时展示当前用户名。让我们来首先添加这些功能所需要的 API 查询到<code>operations.graphql</code>中：</p>

<pre><code class="language-graphql">query Me {
  me {
    id
    fullName
  }
}

mutation SignMeIn($email: String!) {
  signIn(email: $email) {
    token
    user {
      id
      fullName
    }
  }
}
</code></pre>

<p>我们定义了<code>SignMeIn</code> operation，带所需的<code>$email</code>参数，为<code>String</code>类型，“执行”<code>signIn</code> mutation 并在成功时返回一个验证 token 和当前用户信息。你可能注意到了<code>Me</code>和<code>SignMeIn</code> operation上的某些重复——别担心，稍后我们会展示如何处理它们。</p>

<p>再打开<code>index.js</code>并使用上面定义的 operation 来定义我们的组件。我们期望先加载用户信息，且仅当用户没有被身份验证时才展示“Sign In”表单：</p>

<pre><code class="language-js">&lt;Query query={Me}&gt;
  {({ data, loading }) =&gt; {
    if (loading) return "...Loading";
    if (!data.me) {
      // Show login form
      return;
    }

    const { fullName } = data.me;
    return &lt;div className={cs.info}&gt;😈 {fullName}&lt;/div&gt;;
  }}
&lt;/Query&gt;
</code></pre>

<p>要显示表单，我们应当使用<code>Mutation</code>组件并传递<code>SignMeIn</code> operation 为一个<code>mutation</code> property：</p>

<pre><code class="language-js">&lt;Mutation mutation={SignMeIn}&gt;
  {(signIn, { loading: authenticating }) =&gt;
    authenticating ? (
      "..."
    ) : (
      &lt;form onSubmit={() =&gt; signIn(/* email here */)}&gt;
        &lt;input type="email" /&gt;
        &lt;input type="submit" value="Sign In" /&gt;
      &lt;/form&gt;
    )
  }
&lt;/Mutation&gt;
</code></pre>

<p>别忘了导入 <code>userRef</code> hook，<code>Query</code>和<code>Mutation</code>组件，跟该组件中使用的 query 一起：</p>

<pre><code class="language-js">import React, { useRef } from 'react';
import { Query, Mutation } from "react-apollo";
import { Me, SignMeIn } from "./operations.graphql";
</code></pre>

<p>这段代码看起来很像前面创建的<code>Library</code>组件。<code>Mutation</code>组件的 render prop 接收一个执行 mutation 的函数作为第一个参数（<code>signIn</code>），而第二个参数是一个 mutation 结果 object 的 object，包含返回的数据，加载的状态等等。</p>

<p>要传递 email 给 mutation，我们需要从 input（使用<code>ref</code>）来获取它，把它放入<code>variable</code>内，并执行 mutation：</p>

<pre><code class="language-js">const UserInfo = () =&gt; {
  const input = useRef(null);

  // ...

  return (
    &lt;form
      onSubmit={event =&gt; {
        event.preventDefault();
        signIn({
          variables: { email: input.current.value }
        });
      }}
    &gt;
      &lt;input
        ref={input}
        type="email"
        className={cs.input}
        placeholder="your email"
      /&gt;
    &lt;/form&gt;
  );
};
</code></pre>

<p>当在 JavaScript 中调用 mutation 时，我们以如下方式把值绑定到 variables：使用跟 operation 中同样的名称，但不要<code>$</code>前缀，比如，<code>signIn({ variables: { email: '...' } })</code>。</p>

<p><img src="https://cdn.evilmartians.com/front/posts/graphql-on-rails-2-updating-the-data/mutation_variables-9cf2be2.png" alt="https://cdn.evilmartians.com/front/posts/graphql-on-rails-2-updating-the-data/mutation_variables-9cf2be2.png" /></p>

<p>让我们确保把 token 存储到某个地方以便在随后的请求和页面重载重用它：</p>

<pre><code class="language-js">&lt;form
  onSubmit={event =&gt; {
    event.preventDefault();
    signIn({
      variables: { email: input.current.value },
    }).then(({ data: { signIn: { token } } }) =&gt; {
      if (token) {
        localStorage.setItem('mlToken', token);
      }
    });
  }}
&gt;
</code></pre>

<p>在我们执行“Sign In”之后，就应该更新用户信息了（通过<code>Me</code> query）。</p>

<h3 id="dealing-with-cache">Dealing with cache</h3>

<p>有两种选择可以做到这点：</p>

<ul>
  <li>当 mutation 完成时重新请求<code>me</code> query（我们可以使用<code>Mutation</code>组件上<code>refetchQueries</code> property）——这个是有用的，但有更好的方式。</li>
  <li>等待 mutation 完成并手动更新缓存。<code>apollo-cache-inmemory</code>为此提供了<code>writeQuery</code>函数。而<code>react-apollo</code>库的<code>Mutation</code>组件有一个称为<code>update</code>的特殊 property。它接收<code>cache</code>作为第一个参数，mutation 结果作为第二个参数。我们想要使用<code>writeQuery</code>方法手动添加一个新的缓存数据。这就好比在说“Hey，Apollo！这儿有一些数据，假装你是从服务端接收到它们的吧。”</li>
</ul>

<pre><code class="language-js">&lt;Mutation
  mutation={SignMeIn}
  update={(cache, { data: { signIn } }) =&gt; {
    cache.writeQuery({
      query: Me,
      data: { me: signIn.user },
    });
  }}
&gt;
</code></pre>

<p>如下就是<code>UserInfo</code>组件最终看起来的样子：</p>

<pre><code class="language-js">import React, { useRef } from "react";
import { Query, Mutation } from "react-apollo";
import { Me, SignMeIn } from "./operations.graphql";
import cs from "./styles";

const UserInfo = () =&gt; {
  const input = useRef(null);

  return (
    &lt;div className={cs.panel}&gt;
      &lt;Query query={Me}&gt;
        {({ data, loading }) =&gt; {
          if (loading) return "...Loading";
          if (!data.me) {
            return (
              &lt;Mutation
                mutation={SignMeIn}
                update={(cache, { data: { signIn } }) =&gt; {
                  cache.writeQuery({
                    query: Me,
                    data: { me: signIn.user }
                  });
                }}
              &gt;
                {(signIn, { loading: authenticating }) =&gt;
                  authenticating ? (
                    "..."
                  ) : (
                    &lt;div className={cs.signIn}&gt;
                      &lt;form
                        onSubmit={event =&gt; {
                          event.preventDefault();
                          signIn({
                            variables: { email: input.current.value }
                          }).then(({ data: { signIn: { token } } }) =&gt; {
                            if (token) {
                              localStorage.setItem("mlToken", token);
                            }
                          });
                        }}
                      &gt;
                        &lt;input
                          ref={input}
                          type="email"
                          className={cs.input}
                          placeholder="your email"
                        /&gt;
                        &lt;input
                          type="submit"
                          className={cs.button}
                          value="Sign In"
                        /&gt;
                      &lt;/form&gt;
                    &lt;/div&gt;
                  )
                }
              &lt;/Mutation&gt;
            );
          }

          const { fullName } = data.me;
          return &lt;div className={cs.info}&gt;😈 {fullName}&lt;/div&gt;;
        }}
      &lt;/Query&gt;
    &lt;/div&gt;
  );
};

export default UserInfo;
</code></pre>

<p>恭喜！我们刚刚通过添加<code>useRef</code>到组件而购买了一张称作<a href="https://reactjs.org/docs/hooks-intro.html">“React Hooks”</a>的火车票。</p>

<p>更好的做法是把<code>UserInfo</code>拆分为两个单独的组件。第一个负责“Sign In”逻辑，第二个负责用户信息展示。你来自己搞定它吧！</p>

<p>别忘了把组件添加到<code>/javascript/packs/index.js</code>：</p>

<pre><code class="language-js">// app/javascript/packs/index.js

import React from "react";
import { render } from "react-dom";
import Provider from "../components/Provider";
import Library from "../components/Library";
import UserInfo from "../components/UserInfo";

render(
  &lt;Provider&gt;
    &lt;UserInfo /&gt;
    &lt;Library /&gt;
  &lt;/Provider&gt;,
  document.querySelector("#root")
);
</code></pre>

<h3 id="adding-tokens-to-apollo-client">Adding tokens to Apollo client</h3>

<p>运行我们的应用程序，试着使用一个合法 email 登录。</p>

<p>一切正常，除了当你重新加载页面时——你会看到登录表单再次出现，即使你之前已成功登录了！解释很简单：我们把 token 存放在浏览器中，但没有“教” Apollo 使用它。让我们来修复这个问题！</p>

<p>看一下<code>utils/apollo.js</code>：</p>

<pre><code class="language-js">// app/javascript/utils/apollo.js
// ...
const getToken = () =&gt;
  document.querySelector('meta[name="csrf-token"]').getAttribute("content");
const token = getToken();
const setTokenForOperation = async operation =&gt;
  operation.setContext({
    headers: {
      "X-CSRF-Token": token
    }
  });
</code></pre>

<p>我们已经有一个 CSRF token 发送到服务端了。再来添加一个新的——“Authorization” token：</p>

<pre><code class="language-js">// app/javascript/utils/apollo.js
// ...
const getTokens = () =&gt; {
  const tokens = {
    "X-CSRF-Token": document
      .querySelector('meta[name="csrf-token"]')
      .getAttribute("content")
  };
  const authToken = localStorage.getItem("mlToken");
  return authToken ? { ...tokens, Authorization: authToken } : tokens;
};

const setTokenForOperation = async operation =&gt; {
  return operation.setContext({
    headers: {
      ...getTokens()
    }
  });
};
</code></pre>

<p>再登录试试，重载页面——你会看到信息栏的用户名了！我们的“幸运之路”看起来畅通无阻。身份验证流程 ✅</p>

<h2 id="mutating-the-library">Mutating the library</h2>

<p>现在我们要添加一些更多的 mutation ——这里没什么新东西，但我们需要它来使范例应用看起来更好，并得到更多的实践机会。</p>

<p>我们来增加一个 mutation 以向图书馆添加新 item。照例，我们需要定义传入参数和返回类型：</p>

<pre><code class="language-ruby"># app/graphql/mutations/add_item_mutation.rb

module Mutations
  class AddItemMutation &lt; Mutations::BaseMutation
    argument :title, String, required: true
    argument :description, String, required: false
    argument :image_url, String, required: false

    field :item, Types::ItemType, null: true
    field :errors, [String], null: false

    def resolve(title:, description: nil, image_url: nil)
      if context[:current_user].nil?
        raise GraphQL::ExecutionError,
              "You need to authenticate to perform this action"
      end

      item = Item.new(
        title: title,
        description: description,
        image_url: image_url,
        user: context[:current_user]
      )

      if item.save
        { item: item }
      else
        { errors: item.errors.full_messages }
      end
    end
  end
end
</code></pre>

<p>这段代码里有几个要注意的地方：</p>

<ul>
  <li>我们检查<code>context[:current_user]</code>的存在，如果其未设定则抛出异常。</li>
  <li>我们返回的类型包含两个字段：<code>item</code>和<code>errors</code>。为什么不用<code>save!</code>并抛出异常？用户输入的校验错误不应该被看作异常；我们的前端应用应把其视为一种合法响应并反馈给用户。</li>
</ul>

<p>其他的一切都看起来像是典型的 Rails controller 中的旧式<code>#create</code>行为。而如同<code>#update</code>的类似行为也非常简单：</p>

<pre><code class="language-ruby"># app/graphql/mutations/update_item_mutation.rb

module Mutations
  class UpdateItemMutation &lt; Mutations::BaseMutation
    argument :id, ID, required: true
    argument :title, String, required: true
    argument :description, String, required: false
    argument :image_url, String, required: false

    field :item, Types::ItemType, null: true
    field :errors, [String], null: false

    def resolve(id:, title:, description: nil, image_url: nil)
      if context[:current_user].nil?
        raise GraphQL::ExecutionError,
              "You need to authenticate to perform this action"
      end

      item = Item.find(id)

      if item.update(title: title, description: description, image_url: image_url)
        { item: item }
      else
        { errors: item.errors.full_messages }
      end
    end
  end
end
</code></pre>

<p>你可能已经注意到在这两个类中有很多重复——不用担心，本系列的第三部分将涵盖重构的技术内容来修复这个问题。</p>

<p>最后，把新 mutation 注册到<code>MutationType</code>中：</p>

<pre><code class="language-ruby"># app/graphql/types/mutation_type.rb

module Types
  class MutationType &lt; Types::BaseObject
    # ...
    field :add_item, mutation: Mutations::AddItemMutation
    field :update_item, mutation: Mutations::UpdateItemMutation
  end
end
</code></pre>

<h3 id="updating-library-component">Updating Library component</h3>

<p>在开始之前，来重新生成一下我们的 library 组件以遵循新架构（解构 operation，添加样式）：</p>

<pre><code class="language-bash">$ npx @hellsquirrel/create-gql-component create app/javascript/components/Library
</code></pre>

<p>把如下 query 放入<code>operations.graphql</code>中：</p>

<pre><code class="language-graphql">query LibraryQuery {
  items {
    id
    title
    imageUrl
    description
    user {
      id
      email
    }
  }
}
</code></pre>

<p>并“刷新” library 组件的实现方式：</p>

<pre><code class="language-js">// app/javascript/components/Library
import React, { useState } from "react";
import { Query } from "react-apollo";
import { LibraryQuery } from "./operations.graphql";
import cs from "./styles";

const Library = () =&gt; {
  const [item, setItem] = useState(null);
  return (
    &lt;Query query={LibraryQuery}&gt;
      {({ data, loading }) =&gt; (
        &lt;div className={cs.library}&gt;
          {loading || !data.items
            ? "loading..."
            : data.items.map(({ title, id, user, imageUrl, description }) =&gt; (
                &lt;button
                  key={id}
                  className={cs.plate}
                  onClick={() =&gt; setItem({ title, imageUrl, id, description })}
                &gt;
                  &lt;div className={cs.title}&gt;{title}&lt;/div&gt;
                  &lt;div&gt;{description}&lt;/div&gt;
                  {imageUrl &amp;&amp; &lt;img src={imageUrl} className={cs.image} /&gt;}
                  {user ? (
                    &lt;div className={cs.user}&gt;added by {user.email}&lt;/div&gt;
                  ) : null}
                &lt;/button&gt;
              ))}
        &lt;/div&gt;
      )}
    &lt;/Query&gt;
  );
};

export default Library;
</code></pre>

<p>注意，我们把每个 item 都包裹在<code>button</code> HTML 元素内：我们期望它们是可点击的，以展示更新过的表单。现在，我们的前端应用看起来漂亮多了。让我们来添加一些新的亮点吧！</p>

<h3 id="adding-form-components">Adding form components</h3>

<p>我们来为创建和编辑 item 添加更多的组件。这些组件都很类似，所以我们可以把很多逻辑都放到可重用的<code>ProcessItemForm</code>组件内。</p>

<pre><code class="language-bash">$ npx @hellsquirrel/create-gql-component create app/javascript/components/ProcessItemForm
</code></pre>

<p>组件代码如下：</p>

<pre><code class="language-js">// app/javascript/components/ProcessItemForm/index.js

import React, { useState } from "react";
import cs from "./styles";

const ProcessItemForm = ({
  initialTitle = "",
  initialDescription = "",
  initialImageUrl = "",
  onProcessItem,
  buttonText,
  loading
}) =&gt; {
  const [title, setTitle] = useState(initialTitle);
  const [description, setDescription] = useState(initialDescription);
  const [imageUrl, setImageUrl] = useState(initialImageUrl);
  return (
    &lt;div className={cs.form}&gt;
      &lt;input
        type="text"
        placeholder="title"
        value={title}
        className={cs.input}
        onChange={e =&gt; setTitle(e.currentTarget.value)}
      /&gt;
      &lt;input
        type="text"
        placeholder="description"
        value={description}
        className={cs.input}
        onChange={e =&gt; setDescription(e.currentTarget.value)}
      /&gt;

      &lt;input
        type="text"
        placeholder="url"
        value={imageUrl}
        className={cs.input}
        onChange={e =&gt; setImageUrl(e.currentTarget.value)}
      /&gt;
      {loading ? (
        "...Loading"
      ) : (
        &lt;button
          onClick={() =&gt; onProcessItem({ title, description, imageUrl })}
          className={cs.button}
        &gt;
          {buttonText}
        &lt;/button&gt;
      )}
    &lt;/div&gt;
  );
};

export default ProcessItemForm;
</code></pre>

<p>我们唯一所需要添加的是创建 item 的 form——我们把其称为<code>AddItemForm</code>。</p>

<pre><code class="language-bash">$ npx @hellsquirrel/create-gql-component create app/javascript/components/AddItemForm
</code></pre>

<p>我们要把 AddItemMutation 添加到<code>operations.graphql</code>：</p>

<pre><code class="language-graphql"># /app/javascript/components/AddItemForm/operations.graphql

mutation AddItemMutation(
  $title: String!
  $description: String
  $imageUrl: String
) {
  addItem(title: $title, description: $description, imageUrl: $imageUrl) {
    item {
      id
      title
      description
      imageUrl
      user {
        id
        email
      }
    }
  }
}
</code></pre>

<p>并在<code>index.js</code>中使用它：</p>

<pre><code class="language-js">import React from "react";
import { Mutation } from "react-apollo";
import { AddItemMutation } from "./operations.graphql";
import ProcessItemForm from "../ProcessItemForm";

const AddItemForm = () =&gt; (
  &lt;Mutation mutation={AddItemMutation}&gt;
    {(addItem, { loading }) =&gt; (
      &lt;ProcessItemForm
        buttonText="Add Item"
        loading={loading}
        onProcessItem={({ title, description, imageUrl }) =&gt;
          addItem({
            variables: {
              title,
              description,
              imageUrl
            }
          })
        }
      /&gt;
    )}
  &lt;/Mutation&gt;
);

export default AddItemForm;
</code></pre>

<p>别忘了添加 form 到<code>/javascript/packs/index.js</code>：</p>

<pre><code class="language-js">import React from "react";
import { render } from "react-dom";
import Provider from "../components/Provider";
import Library from "../components/Library";
import UserInfo from "../components/UserInfo";
import AddItemForm from "../components/AddItemForm";

render(
  &lt;Provider&gt;
    &lt;UserInfo /&gt;
    &lt;AddItemForm /&gt;
    &lt;Library /&gt;
  &lt;/Provider&gt;,
  document.querySelector("#root")
);
</code></pre>

<p>现在我们遭遇了跟在<code>UserInfo</code>组件中同样的问题。我们需要告知应用：<code>LibraryQuery</code>应该被更新。因此我们必须刷新缓存：通过读取整个列表并把新 item 合并到列表上以设置一个新列表。</p>

<p>来改一下<code>javascript/components/AddItemForm/index.js</code>：</p>

<pre><code class="language-js">// javascript/components/AddItemForm/index.js
// ...
import { LibraryQuery } from '../Library/operations.graphql';
// ...

&lt;ProcessItemForm
  //...
  // Update library query after Mutation will be finished
  onProcessItem={({ title, description, imageUrl }) =&gt;
    addItem({
      variables: {
        title,
        description,
        imageUrl,
      },

      // adding the second argument to 'addItem' method
      update: (cache, { data: { addItem } }) =&gt; {
        const item = addItem.item;
        if (item) {
          const currentItems = cache.readQuery({ query: LibraryQuery });
          cache.writeQuery({
            query: LibraryQuery,
            data: {
              items: [item].concat(currentItems.items),
            },
          });
        }
      },
    })
  }
  // ...
</code></pre>

<p>搞定！现在我们会看到新的 item 被添加到页面列表了。</p>

<p>来为更新 item 再添加一个组件，称为<code>UpdateItemForm</code>。代码非常类似于 AddItemForm。运行生成器：</p>

<pre><code class="language-bash">$ npx @hellsquirrel/create-gql-component create app/javascript/components/UpdateItemForm
</code></pre>

<p>下面是 operations 文件中的内容：</p>

<pre><code class="language-graphql">mutation UpdateItemMutation(
  $id: ID!
  $title: String!
  $description: String
  $imageUrl: String
) {
  updateItem(
    id: $id
    title: $title
    description: $description
    imageUrl: $imageUrl
  ) {
    item {
      id
      title
      description
      imageUrl
    }
  }
}
</code></pre>

<p>这是组件文件中的内容：</p>

<pre><code class="language-js">// /app/javascript/components/UpdateItemForm

import React from "react";
import { Mutation } from "react-apollo";
import { UpdateItemMutation } from "./operations.graphql";
import ProcessItemForm from "../ProcessItemForm";
import cs from "./styles";

const UpdateItemForm = ({
  id,
  initialTitle,
  initialDescription,
  initialImageUrl,
  onClose
}) =&gt; (
  &lt;div className={cs.overlay}&gt;
    &lt;div className={cs.content}&gt;
      &lt;Mutation mutation={UpdateItemMutation}&gt;
        {(updateItem, { loading }) =&gt; (
          &lt;ProcessItemForm
            initialImageUrl={initialImageUrl}
            initialTitle={initialTitle}
            initialDescription={initialDescription}
            buttonText="Update Item"
            loading={loading}
            onProcessItem={({ title, description, imageUrl }) =&gt; {
              updateItem({
                variables: {
                  id,
                  title,
                  description,
                  imageUrl
                }
              });
              onClose();
            }}
          /&gt;
        )}
      &lt;/Mutation&gt;
      &lt;button className={cs.close} onClick={onClose}&gt;
        Close
      &lt;/button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
);

export default UpdateItemForm;
</code></pre>

<p>并把 UpdateItemForm 添加到 library（位于 button 之后）：</p>

<pre><code class="language-js">// /app/javascript/components/Library/index.js

//...
import UpdateItemForm from "../UpdateItemForm";

// ...
&lt;button /&gt;;

{
  item !== null &amp;&amp; (
    &lt;UpdateItemForm
      id={item.id}
      initialTitle={item.title}
      initialDescription={item.description}
      initialImageUrl={item.imageUrl}
      onClose={() =&gt; setItem(null)}
    /&gt;
  )
}
// ...
</code></pre>

<p>现在如果我们点击 item 并修改，它就会神奇地更新了。为什么呢？</p>

<p>当获取一个 item 列表时，响应结果被规范化，且每个 item 都被添加到缓存。<code>apollo</code>为每个有<code>__typename</code>和<code>id</code>的实体都生成一个 key：<code>${object__typename}:${objectId}</code>。当 mutation 完成的时候，我们获取到有相同<code>__typename</code>和<code>id</code>的对象，<code>apollo</code>在缓存中找到它，并进行更改（组件也被重新渲染）。</p>

<p>我们能做得更好一些么？当然！</p>

<p>为什么我们要等待服务端的响应呢？如果我们对服务端有足够的信心，那么我们可以使用乐观式更新。让我们再添加一个参数到 updateItem 函数：</p>

<pre><code class="language-js">// /app/javascript/components/UpdateItemForm

//...
updateItem({
  variables: {
    //...
  },

  // adding the second argument to 'updateItem' method

  optimisticResponse: {
    __typename: "Mutation",
    updateItem: {
      __typename: "UpdateItemMutationPayload",
      item: {
        id,
        __typename: "Item",
        title,
        description,
        imageUrl
      }
    }
  }
});
//..
</code></pre>

<p>这些就是本文的全部内容了！我们学习了 mutation 和 query 之间的区别，学习了在后端如何实现它们，以及如何在前端使用它们。现在，我们的应用支持用户登录和图书馆的管理，所以几乎已准备好发布到 production 了！然而，代码看起来还有些笨拙，有重构的空间——这正是我们将在第三部分中要做的，并添加一些其他改进，例如实时更新和更好的错误处理。敬请关注！</p>


</div>

<!-- Rating -->

<div class="rating mt-4 mb-4 d-flex align-items-center">
    <strong class="mr-1">Rating:</strong> <div class="rating-holder">
<div class="c-rating c-rating--regular" data-rating-value="4">
  <button>1</button>
  <button>2</button>
  <button>3</button>
  <button>4</button>
  <button>5</button>
</div>
</div>
</div>


<!-- Author Box if enabled from _config.yml -->
<!-- Author Box -->


<div class="d-flex authorbox align-items-center">
    <div class="col-md-2 mr-4 text-center">
        
        <img class="author-thumb" src="/assets/images/avatar.png" alt="Mr.Z">
        
    </div>
    <div class="col-md-10"> 
        <a target="_blank" class="text-dark h4" href="https://xfyuan.github.io">About Mr.Z</a>   <a target="_blank" href="https://twitter.com/apexy" class="btn-sm"><i class="fab fa-twitter"></i></a>        
        <span class="author-description d-block mt-2">A Chinese software engineer living and working in Chengdu. I love Creating the future in digital worlds, big and small.</span>            
    </div>
</div>



<!-- Comments if not disabled with comments: false -->
<!-- Comments
================================================== -->
 
<div class="comments">
    <button class="btn btn-dark show-comments">Load Comments</button>         
    <div id="comments">  
        <h4 class="mb-4">Comments</h4>                 
            <section class="disqus">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'xfyuan'; 
        var disqus_developer = 0;
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = window.location.protocol + '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>
     
    <div class="clearfix"></div>              
    </div>    
</div>       


<!-- Share -->
<div class="share">
    <p>
        Share
    </p>
    <ul>
        <li class="ml-1 mr-1">
            <a target="_blank" href="https://twitter.com/intent/tweet?text=GraphQL on Rails——更新&url=/2020/11/graphql-on-rails-series-2/" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                <i class="fab fa-twitter"></i>
            </a>
        </li>

        <li class="ml-1 mr-1">
            <a target="_blank" href="https://facebook.com/sharer.php?u=/2020/11/graphql-on-rails-series-2/" onclick="window.open(this.href, 'facebook-share', 'width=550,height=435');return false;">
                <i class="fab fa-facebook-f"></i>
            </a>
        </li>

        <li class="ml-1 mr-1">
            <a target="_blank" href="https://www.linkedin.com/shareArticle?mini=true&url=/2020/11/graphql-on-rails-series-2/" onclick="window.open(this.href, 'width=550,height=435');return false;">
                <i class="fab fa-linkedin-in"></i>
            </a>
        </li>

    </ul>
</div>


<!-- Related Post -->
<!-- Related Posts
================================================== -->
<div class=" related-posts ">  

    
    <h2 class="text-center mb-4">Explore more like this</h2>
    
    
    <div class="d-flex justify-content-center align-items-center">
    
    <!-- Categories -->
    
    
    <a class="smoothscroll badge badge-primary text-capitalize" href="/categories#Programming">Programming</a>                
    
    <a class="smoothscroll badge badge-primary text-capitalize" href="/categories#Translation">Translation</a>                
    

    <!-- Tags -->  
    
                    
    <a class="smoothscroll badge badge-primary text-capitalize" href="/tags#graphql">graphql</a>               
                    
    <a class="smoothscroll badge badge-primary text-capitalize" href="/tags#rails">rails</a>               
                    
    <a class="smoothscroll badge badge-primary text-capitalize" href="/tags#ruby">ruby</a>               
    

    </div>

    
    
    
    <div class="blog-grid-container">
        
        
            
            
        
            
        
            
            <!-- begin post -->


<div class="blog-grid-item">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="/2021/04/hotwire-reactive-rails-with-no-javascript/">
                

                    
                        <img class="img-thumb lazyimg" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAACCAQAAAA3fa6RAAAADklEQVR42mNkAANGCAUAACMAA2w/AMgAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/xfyuan/ossimgs@master/uPic/IMG_20210220_121324.jpg" alt="Hotwire: 没有JavaScript的Reactive Rails">
                    

                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title">
                <a class="text-dark" href="/2021/04/hotwire-reactive-rails-with-no-javascript/">Hotwire: 没有JavaScript的Reactive Rails</a>
                
                <div class="mb-2 mt-2 font-weight-normal">
                <div class="rating-holder">
<div class="c-rating c-rating--regular" data-rating-value="5">
  <button>1</button>
  <button>2</button>
  <button>3</button>
  <button>4</button>
  <button>5</button>
</div>
</div>
                </div>
                
            </h2>
            <h4 class="card-text">本文已获得原作者（Vladimir Dementyev）和 Evil Martians 授权许可进行翻译。原文介绍了 Rails 的最新“魔法”：Hotwire。这也是 Vladimir Dementyev 在 RailsConf 2021 上的演讲内容。
</h4>
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                <span class="meta-footer-thumb">
                
                <img class="author-thumb" src="/assets/images/avatar.png" alt="Mr.Z">
                
                </span>
                <span class="author-meta">
                <span class="post-name"><a target="_blank" href="https://xfyuan.github.io">Mr.Z</a></span> 
                
                <span class="post-date">24 Apr 2021</span>
                </span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>
<!-- end post -->
            
            
            
        
        
        
            
            
        
            
        
            
            <!-- begin post -->


<div class="blog-grid-item">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="/2021/04/the-foundation-of-how-tailwindcss-works/">
                

                    
                        <img class="img-thumb lazyimg" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAACCAQAAAA3fa6RAAAADklEQVR42mNkAANGCAUAACMAA2w/AMgAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/xfyuan/ossimgs@master/uPic/IMG_20210220_115551.jpg" alt="Tailwindcss底层基石的理念">
                    

                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title">
                <a class="text-dark" href="/2021/04/the-foundation-of-how-tailwindcss-works/">Tailwindcss底层基石的理念</a>
                
            </h2>
            <h4 class="card-text">Tailwindcss 从 2019 年开始逐渐在国外的 Web 开发圈子内盛行起来。国内倒是至今仍然不温不火。2020 年的 Ruby China 上过纯中做过一次在项目上使用 tailwindcss 体验的有关演讲。我在 2020 年也写过一篇有关的博客“在 Rails 6 中整合 Stimulus 和 Tailwind CSS”（被前者在演讲中所引用^_^）。
</h4>
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                <span class="meta-footer-thumb">
                
                <img class="author-thumb" src="/assets/images/avatar.png" alt="Mr.Z">
                
                </span>
                <span class="author-meta">
                <span class="post-name"><a target="_blank" href="https://xfyuan.github.io">Mr.Z</a></span> 
                
                <span class="post-date">10 Apr 2021</span>
                </span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>
<!-- end post -->
            
            
            
        
        
        
            
            
        
            
        
            
            <!-- begin post -->


<div class="blog-grid-item">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="/2021/03/hotwire-build-turbo-application/">
                

                    
                        <img class="img-thumb lazyimg" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAACCAQAAAA3fa6RAAAADklEQVR42mNkAANGCAUAACMAA2w/AMgAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/xfyuan/ossimgs@master/uPic/IMG_20210220_133340.jpg" alt="Hotwire之构建Turbo应用">
                    

                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title">
                <a class="text-dark" href="/2021/03/hotwire-build-turbo-application/">Hotwire之构建Turbo应用</a>
                
            </h2>
            <h4 class="card-text">本文是对构建 Turbo 应用的具体描述，原文出自：https://turbo.hotwire.dev/handbook/building。
</h4>
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                <span class="meta-footer-thumb">
                
                <img class="author-thumb" src="/assets/images/avatar.png" alt="Mr.Z">
                
                </span>
                <span class="author-meta">
                <span class="post-name"><a target="_blank" href="https://xfyuan.github.io">Mr.Z</a></span> 
                
                <span class="post-date">26 Mar 2021</span>
                </span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>
<!-- end post -->
            
            
                
        </div>        
</div>

<!-- Review with LD-JSON, adapt it for your needs if you like, but make sure you test the generated HTML source code first: 
https://search.google.com/structured-data/testing-tool/u/0/
================================================== -->

    <script type="application/ld+json">
    {
    "@context": "http://schema.org/",
    "@type": "Review",
    "itemReviewed": {
    "@type": "Thing",
    "name": "GraphQL on Rails——更新"
    },
    "author": {
    "@type": "Person",
    "name": "Mr.Z"
    },
    "datePublished": "2020-11-24",
    "reviewRating": {
    "@type": "Rating",
    "ratingValue": "4",
    "bestRating": "5"
    }
    }
    </script>

    </div>

    

</div>

<!-- Begin Footer
================================================== -->
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-12 text-center text-lg-left">
                Copyright © 2021 The Tragedy of XY
            </div>
            <div class="col-md-6 col-sm-12 text-center text-lg-right">
                <a target="_blank" href="https://www.wowthemes.net/memoirs-free-jekyll-theme/">Memoirs Jekyll Theme</a>
            </div>
        </div>
    </div>
</footer>
<!-- End Footer
================================================== -->

</div> <!-- /.site-content -->

<!-- Scripts (if you need bootstrap.js, please add it yourself. I didn't use it for performance reasons, it was not needed in this theme)
================================================== -->

<script src="/assets/js/prism.js"></script>

<script src="/assets/js/theme.js"></script>


<script src="/assets/js/lazyload.js"></script>



<script id="dsq-count-scr" src="//xfyuan.disqus.com/count.js"></script>


</body>
</html>
