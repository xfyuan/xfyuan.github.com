<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<link rel="icon" href="/assets/images/logo.png">

<title>GraphQL on Rails——至臻 | The Tragedy of XY</title>

<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>GraphQL on Rails——至臻 | The Tragedy of XY</title>
<meta name="generator" content="Jekyll v4.1.0" />
<meta property="og:title" content="GraphQL on Rails——至臻" />
<meta name="author" content="Mr.Z" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="本文已获得原作者（Dmitry Tsepelev）、（Polina Gurtovaya）和 Evil Martians 授权许可进行翻译。原文是 Rails + React 使用 GraphQL的系列教程第三篇，介绍了以 Rails 作为后端，React + Apollo 作为前端，如何进行重构、错误处理以及实时更新等高级主题和技巧。" />
<meta property="og:description" content="本文已获得原作者（Dmitry Tsepelev）、（Polina Gurtovaya）和 Evil Martians 授权许可进行翻译。原文是 Rails + React 使用 GraphQL的系列教程第三篇，介绍了以 Rails 作为后端，React + Apollo 作为前端，如何进行重构、错误处理以及实时更新等高级主题和技巧。" />
<meta property="og:site_name" content="The Tragedy of XY" />
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xfyuan/ossimgs@master/uPic/IMG_20200924_133643.jpg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-11-28T00:00:00+00:00" />
<script type="application/ld+json">
{"dateModified":"2020-11-28T00:00:00+00:00","datePublished":"2020-11-28T00:00:00+00:00","description":"本文已获得原作者（Dmitry Tsepelev）、（Polina Gurtovaya）和 Evil Martians 授权许可进行翻译。原文是 Rails + React 使用 GraphQL的系列教程第三篇，介绍了以 Rails 作为后端，React + Apollo 作为前端，如何进行重构、错误处理以及实时更新等高级主题和技巧。","url":"/2020/11/graphql-on-rails-series-3/","@type":"BlogPosting","image":"https://cdn.jsdelivr.net/gh/xfyuan/ossimgs@master/uPic/IMG_20200924_133643.jpg","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"/assets/images/logo.png"},"name":"Mr.Z"},"mainEntityOfPage":{"@type":"WebPage","@id":"/2020/11/graphql-on-rails-series-3/"},"author":{"@type":"Person","name":"Mr.Z"},"headline":"GraphQL on Rails——至臻","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


<link href="/assets/css/prism.css" rel="stylesheet">

<link href="/assets/css/theme.css" rel="stylesheet">

<script src="/assets/js/jquery.min.js"></script>

</head>




<body>
	<!-- defer loading of font and font awesome -->
	<noscript id="deferred-styles">
		<link href="https://fonts.googleapis.com/css?family=Sen:400,700&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	</noscript>

<!-- Begin Sidebar Navigation
================================================== -->

<div class="sidebar">
</div>
<div class="nav-icon">
    <div class="hamburger-bar"></div>
</div>
<div id="blackover-nav" class="blackover"></div>
<nav id="menu">
    <ul>
        <h3>Navigation</h3>
        <li><a href="/">Home</a></li>
        <li><a href="/categories">Categories</a></li>
        <li><a href="/about">About</a></li>
    </ul>
</nav>

<script src="/assets/js/lunr.js"></script>

<style>
    
</style>

<div class="wrap-search">
    <div class="d-flex align-items-center ml-auto">
        <i class="fas fa-search show-search"></i>
        <form class="bd-search ml-3" onSubmit="return lunr_search(document.getElementById('lunrsearch').value);">
            <input type="text" class="form-control bigradius text-small launch-modal-search" id="lunrsearch" name="q" maxlength="255" value="" placeholder="Type and enter..."/>
        </form>
    </div>
</div>

<div id="lunrsearchresults">
    <ul></ul>
</div>

<script src="/assets/js/lunrsearchengine.js"></script>


<!-- End Sidebar Navigation
================================================== -->

<div class="site-content ">

<div class="container">

    <!-- Site Logo/Name
    ================================================== -->

    <a class="navbar-brand" href="/">
        <img src="/assets/images/logo.png" alt="The Tragedy of XY">
    </a>


    <!-- Site Tag
    ================================================== -->
    

    <!-- Content
    ================================================== -->
    <div class="main-content">
        <div class="entry-header">
    <!-- Post Title -->
    <h1 class="posttitle">GraphQL on Rails——至臻</h1>
    <!-- Author & Date  Box -->
    
    
    <div class="d-flex align-items-center mt-4">
        <div>
            
            <img class="author-thumb" src="/assets/images/avatar.png" alt="Mr.Z">
            
        </div>            
        <div>
        Written by <a target="_blank" class="text-dark" href="https://xfyuan.github.io">Mr.Z</a> on 
        <span class="post-date"><time class="post-date" datetime="2020-11-28">28 Nov 2020</time></span>           
        
        </div>            
    </div>
    
</div>

<!-- Adsense under title if enabled from _config.yml (change your pub id and slot) -->


<!-- Featured Image -->

<div class="entry-featured-image">
    
    <img class="featured-image lazyimg " src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAACCAQAAAA3fa6RAAAADklEQVR42mNkAANGCAUAACMAA2w/AMgAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/xfyuan/ossimgs@master/uPic/IMG_20200924_133643.jpg" alt="GraphQL on Rails——至臻">
    
</div>


<!-- Content -->
<!-- Post, Page Content
================================================== -->
<div class="article-post">
    <!-- Toc if any -->
    
    <!-- End Toc -->
    <p><em>本文已获得原作者（Dmitry Tsepelev）、（Polina Gurtovaya）和 Evil Martians 授权许可进行翻译。原文是 Rails + React 使用 GraphQL的系列教程第三篇，介绍了以 Rails 作为后端，React + Apollo 作为前端，如何进行重构、错误处理以及实时更新等高级主题和技巧。</em></p>

<ul>
  <li>原文链接：<a href="https://evilmartians.com/chronicles/graphql-on-rails-3-on-the-way-to-perfection">GraphQL on Rails: On the way to perfection</a></li>
  <li>作者：<a href="https://twitter.com/dmitrytsepelev">Dmitry Tsepelev</a>，<a href="https://github.com/HellSquirrel">Polina Gurtovaya</a></li>
  <li>站点：Evil Martians ——位于纽约和俄罗斯的 Ruby on Rails 开发人员博客。 它发布了许多优秀的文章，并且是不少 gem 的赞助商。</li>
</ul>

<p><em>【正文如下】</em></p>

<h2 id="引言">引言</h2>

<p><strong>这是一个在后端使用 Rails、前端使用 React/Apollo 来开发 GraphQL 应用程序的旅行者指导。本教程的第三也是最后一部分都是关于实时更新的内容，以及 DRY 代码和实现更好的错误处理。</strong></p>

<p>在本教程的前一部分里，我们已经构建了 Martian Library 应用程序的原型：用户可以在一个现代的 SPA 页面中动态地管理有关红色星球的制品。但还没到坐下休息放松的时候，因为我们还有一些重构要做。</p>

<p>如果你是从前两部分一路编写了代码——就用你自己的代码即可，如果不是——那么可以从<a href="https://github.com/evilmartians/chronicles-gql-martian-library">这里</a>拉取。</p>

<h2 id="all-you-need-is-dry">All you need is DRY</h2>

<p>让我们从后端开始来对 item 的 mutation（<code>AddItemMutation</code>和<code>UpdateItemMutation</code>）进行 一些 DRY 处理。我们有一些验证用户是否登录的重复代码：</p>

<pre><code class="language-ruby"># app/graphql/mutations/add_item_mutation.rb

module Mutations
  class AddItemMutation &lt; Mutations::BaseMutation
    # ...

    def resolve
      if context[:current_user].nil?
        raise GraphQL::ExecutionError,
              "You need to authenticate to perform this action"
      end

      save_item
    end
  end
end
</code></pre>

<p>把其移到<code>BaseMutation</code>类中：</p>

<pre><code class="language-ruby"># app/graphql/mutations/base_mutation.rb

module Mutations
  class BaseMutation &lt; GraphQL::Schema::Mutation
    def check_authentication!
      return if context[:current_user]

      raise GraphQL::ExecutionError,
            "You need to authenticate to perform this action"
    end
  end
end
</code></pre>

<p>经过这样的修改，你就可以把<code>AddItemMutation</code>和<code>UpdateItemMutation</code>中的代码替换为<code>check_authentication!</code>的调用。这只是一个我们可以如何使用<code>BaseMutation</code>的例子罢了。在真实的应用程序中，它可以包含许多针对重复性工作的有用的帮助方法。</p>

<p>现在，让我们来看看前端代码。这里有怎样的代码重复呢？</p>

<p><img src="https://cdn.evilmartians.com/front/posts/graphql-on-rails-3-on-the-way-to-perfection/front_duplication-8ee24ae.png" alt="https://cdn.evilmartians.com/front/posts/graphql-on-rails-3-on-the-way-to-perfection/front_duplication-8ee24ae.png" /></p>

<p>三个 query 看起来都非常类似：在<code>Item</code> query 中我们所选择的字段几乎是一样的。我们可以怎样避免这些重复？</p>

<p>幸运的是，GraphQL 有其自身的“variables”，称作 <a href="https://graphql.github.io/graphql-spec/draft/#sec-Language.Fragments"><em>fragments</em></a>.。一个 fragment 就是一个在特定类型上的命名字段集。</p>

<p>该是创建我们第一个 fragment 的时候了：</p>

<pre><code class="language-bash">$ mkdir -p app/javascript/fragments &amp;&amp; touch app/javascript/fragments/Item.graphql
</code></pre>

<p>把所有重复的字段放入其中：</p>

<pre><code class="language-graphql">fragment ItemFragment on Item {
  id
  title
  imageUrl
  description
}
</code></pre>

<p>现在我们需要把 fragment 添加到<code>AddItemForm</code>、<code>UpdateItemForm</code>和<code>Library</code>中的所有 operation 上。例如，<code>Library</code>组件中的 query 看起来会是这样：</p>

<pre><code class="language-graphql">#app/javascript/components/Library/operations.graphql
#import '../../fragments/Item.graphql'

query LibraryQuery {
  items {
    ...ItemFragment
    user {
      id
      email
    }
  }
}
</code></pre>

<h2 id="dealing-with-errors">Dealing with errors</h2>

<p>我们知道，如果请求没有引起服务端报错的话，GraphQL 总是响应为 <em>200 OK</em>。通常有两种类型的错误发生：用户输入错误（校验）和异常。</p>

<ul>
  <li><em>校验错误</em> 仅出现在 mutation 中，它们被包含在所返回的数据里。为用户提供有用的反馈，以显示在 UI 上。</li>
  <li><em>异常</em> 可以出现在任何 query 中，指示 query 里有什么东西出错了：例如，身份验证/权限的问题，无法处理的输入数据，等等（看后面内容）。如果响应包含异常，客户端就必须“尽全力失败”（比如，展示一个错误页面）。</li>
</ul>

<p>从前端角度来看，对于错误我们可以如何做呢？</p>

<p>首先，我们可以设置一个错误日志记录器，来快速检测并修复错误（我们已经在<a href="https://evilmartians.com/chronicles/graphql-on-rails-1-from-zero-to-the-first-query">第一部分</a>中配置好了）。</p>

<p>其次，把组件封装在<a href="https://reactjs.org/docs/error-boundaries.html">错误边界</a>内是一个好主意，并在出现问题时用悲伤的开发者面孔显示错误屏幕。</p>

<p>第三，我们应该通过查阅文档来避免常见错误。当心点号并正确处理那些可为 null 的字段！看看你的 GraphiQL 文档中的<code>me</code> query：</p>

<p><img src="https://cdn.evilmartians.com/front/posts/graphql-on-rails-3-on-the-way-to-perfection/me_docs-d7f115c.png" alt="https://cdn.evilmartians.com/front/posts/graphql-on-rails-3-on-the-way-to-perfection/me_docs-d7f115c.png" /></p>

<p>根据文档，<code>me</code>是一个<em>可为 null</em> 的字段。我们不能随便使用诸如<code>me.email</code>的表达式，而需要确保 user 是存在的。</p>

<p>最后，我们应该在 <a href="https://reactjs.org/docs/render-props.html">render prop</a> 函数内处理 GraphQL 错误。下面很快会向你展示如何来做。</p>

<p>当用户提交了非法数据，后端返回一个字符串的错误消息列表。让我们来修改下处理错误的方式：将会返回一个 object，包含同样的错误消息列表，但也包含一些 JSON 编码的细节。细节可用于生成客户端消息，或向用户提供额外的反馈（比如，高亮非法的表单字段）。</p>

<p>首先，来定义一个新的<code>ValidationErrorsType</code>：</p>

<pre><code class="language-ruby"># app/graphql/types/validation_errors_type.rb

module Types
  class ValidationErrorsType &lt; Types::BaseObject
    field :details, String, null: false
    field :full_messages, [String], null: false

    def details
      object.details.to_json
    end
  end
end
</code></pre>

<p>现在，我们需要修改<code>AddItemMutation</code>来使用所定义的新类型（请为<code>UpdateItemMutation</code>做同样的事）：</p>

<pre><code class="language-ruby"># app/graphql/mutations/add_item_mutation.rb

module Mutations
  class AddItemMutation &lt; Mutations::BaseMutation
    argument :title, String, required: true
    argument :description, String, required: false
    argument :image_url, String, required: false

    field :item, Types::ItemType, null: true
    field :errors, Types::ValidationErrorsType, null: true # this line has changed

    def resolve(title:, description: nil, image_url: nil)
      check_authentication!

      item = Item.new(
        title: title,
        description: description,
        image_url: image_url,
        user: context[:current_user]
      )

      if item.save
        { item: item }
      else
        { errors: item.errors } # change here
      end
    end
  end
end
</code></pre>

<p>最后，来为 item model 添加对应的校验：</p>

<pre><code class="language-ruby"># app/models/item.rb

class Item &lt; ApplicationRecord
  belongs_to :user

  validates :title, presence: true
  validates :description, length: { minimum: 10 }, allow_blank: true
end
</code></pre>

<p>现在，我们需要在接口中使用这些校验。我们应该为<code>AddItemForm</code>和<code>UpdateItemForm</code>更新逻辑。我们将为你展示对<code>AddItemForm</code>如何做，至于<code>UpdateItemForm</code>的代码，就留给读者作为一个练习了（当然，你可以在<a href="https://github.com/evilmartians/chronicles-gql-martian-library/blob/1ea31575aa35246052678be8e9506fe7099db6a8/app/javascript/components/UpdateItemForm/index.js">这儿</a>找到解决办法）。</p>

<p>让我们先来为<code>operations.graphql</code>添加一个<code>errors</code>字段：</p>

<pre><code class="language-graphql">#/app/javascript/components/AddItemForm/operations.graphql
#import '../../fragments/Item.graphql'

mutation AddItemMutation(
  $title: String!
  $description: String
  $imageUrl: String
) {
  addItem(title: $title, description: $description, imageUrl: $imageUrl) {
    item {
      ...ItemFragment
      user {
        id
        email
      }
    }
    errors { # new field
      fullMessages
    }
  }
}
</code></pre>

<p>现在，我们需要在<code>AddItemForm</code>及其上一级的<code>ProcessItemForm</code>中做一点小的改动，为错误添加一个新元素：</p>

<pre><code class="language-js">// app/javascript/components/ProcessItemForm/index.js
const ProcessItemForm = ({
  // ...
  errors,
}) =&gt; {
  // ...
  return (
    &lt;div className={cs.form}&gt;
      {errors &amp;&amp; (
        &lt;div className={cs.errors}&gt;
          &lt;div className="error"&gt;{errors.fullMessages.join('; ')}&lt;/div&gt;
        &lt;/div&gt;
      )}
      {/* ... */}
    &lt;/div&gt;
  );
};

export default ProcessItemForm;
</code></pre>

<p>而在<code>Mutation</code>组件中，我们就从<code>data</code> property 抓取错误：</p>

<pre><code class="language-js">// app/javascript/components/AddItemForm/index.js
// ...
&lt;Mutation mutation={AddItemMutation}&gt;
  {(addItem, { loading, data }) =&gt; ( // getting data from response
    &lt;ProcessItemForm
      buttonText="Add Item"
      loading={loading}
      errors={data &amp;&amp; data.addItem.errors} /&gt;
      // ...
    )
  }
&lt;/Mutation&gt;
</code></pre>

<p>如果你想要错误信息显示得更漂亮一点，就在<code>/app/javascript/components/ProcessItemForm/styles.module.css</code>添加如下样式：</p>

<pre><code class="language-css">.form {
  position: relative;
}

.errors {
  position: absolute;
  top: -20px;
  color: #ff5845;
}
</code></pre>

<p>现在，让我们来谈论下 GraphQL 的第二种错误：<em>异常</em>。教程的前一章里，我们已经实现了身份验证，但没有实现一种处理用户带不存在 email 的方式。这不是所期望的行为，所以我们要确保抛出一个异常：</p>

<pre><code class="language-ruby"># app/graphql/mutations/sign_in_mutation.rb

module Mutations
  class SignInMutation &lt; Mutations::BaseMutation
    argument :email, String, required: true

    field :token, String, null: true
    field :user, Types::UserType, null: true

    def resolve(email:)
      user = User.find_by!(email: email)

      token = Base64.encode64(user.email)

      {
        token: token,
        user: user
      }
    rescue ActiveRecord::RecordNotFound
      raise GraphQL::ExecutionError, "user not found"
    end
  end
end
</code></pre>

<p>我们需要更改前端代码来优雅处理这种情形。在<code>UserInfo</code>组件中来做。从 render prop 函数所提供的对象中为<code>Mutation</code>组件抓取错误参数：</p>

<pre><code class="language-js">// app/javascript/components/UserInfo/index.js

const UserInfo = () =&gt; {
  // ...
  {(signIn, { loading: authenticating, error /* new key */ }) =&gt; {
  }}
  // ...
}
</code></pre>

<p>并在<code>&lt;/form&gt;</code> 前添加一个元素来显示错误：</p>

<pre><code class="language-js">// app/javascript/components/UserInfo/index.js

const UserInfo = () =&gt; {
  &lt;form&gt;
    // ...
    {error &amp;&amp; &lt;span&gt;{error.message}&lt;/span&gt;}
  &lt;/form&gt;
  // ...
}
</code></pre>

<h2 id="handling-input-data">Handling input data</h2>

<p>让我们再回到<code>AddItemMutation</code>和<code>UpdateItemMutation</code>。看看 argument 列表，问问你自己，为什么我们有两个几乎相同的列表呢？每次我们向<code>Item</code> model 添加新字段，都需要添加新 argument 两次，这可不好。</p>

<p>解决办法相当简单：使用一个单独的 argument，包含所有需要的字段。<code>graphql-ruby</code>有一个称为<code>BaseInputObject</code>的特殊事物，用来定义类似如此的 argument 类型。我们来创建一个名为<code>item_attributes.rb</code>的文件：</p>

<pre><code class="language-ruby"># app/graphql/types/item_attributes.rb

module Types
  class ItemAttributes &lt; Types::BaseInputObject
    description "Attributes for creating or updating an item"

    argument :title, String, required: true
    argument :description, String, required: false
    argument :image_url, String, required: false
  end
end
</code></pre>

<p>这个看起来很像之前所创建的类型，但有一个根本的区别：<code>argument</code>替代了 field。这是为什么？因为 GraphQL 遵循了 CQRS 原则，以两个不同的 model 来处理数据：读的 model（type）和写的 model（input）。</p>

<p>当心：你不能使用复杂类型作为 argument 类型——它只能是标量类型或其他 input 类型。</p>

<p>现在，我们可以把 mutation 更改为使用这个 argument 了。来从<code>AddItemMutation</code>开始：</p>

<pre><code class="language-ruby"># app/graphql/mutations/add_item_mutation.rb

module Mutations
  class AddItemMutation &lt; Mutations::BaseMutation
    argument :attributes, Types::ItemAttributes, required: true # new argument

    field :item, Types::ItemType, null: true
    field :errors, Types::ValidationErrorsType, null: true # &lt;= change here

    # signature change
    def resolve(attributes:)
      check_authentication!

      item = Item.new(attributes.to_h.merge(user: context[:current_user])) # change here

      if item.save
        { item: item }
      else
        { errors: item.errors }
      end
    end
  end
end
</code></pre>

<p>如你所见，我们用一个名为<code>attributes</code>的单独 argument 替换了整个 argument 列表，修改<code>#resolve</code>以接收它，并稍微变更了我们创建 item 的方式。请对<code>UpdateItemMutation</code>进行同样的调整。现在我们需要修改前端代码来适配这些改动了。</p>

<p>我们唯一要做的就是添加一个单词和两个大括号到 mutation 上（对于<code>UpdateItem</code>也应该做同样的修改）：</p>

<pre><code class="language-js">#/app/javascript/components/AddItemForm/operations.graphql
#import '../../fragments/Item.graphql'

mutation AddItemMutation(
  $title: String!
  $description: String
  $imageUrl: String
) {
  addItem(
    attributes: { # just changing the shape
      title: $title
      description: $description
      imageUrl: $imageUrl
    }
  ) {
    item {
      ...ItemFragment
      user {
        id
        email
      }
    }
    errors {
      fullMessages
    }
  }
}
</code></pre>

<h2 id="implementing-real-time-updates">Implementing real-time updates</h2>

<p>服务端发起的更新在现代应用中很常见：我们的场景里，对于用户，在有人添加新 item 或修改现有 item 时，让其列表得到更新是很有用的。这正是 GraphQL <em>subscriptions</em> 的目的所在！</p>

<p>Subscription 是一种把服务端所发起的更新发布到客户端的机制。每个更新都返回特别类型的数据：例如，我们可以添加一个 subscription，当有新 item 被添加时就提醒客户端。当我们发送 <em>Subscription</em> operation 到服务端时，它会给我们返回一个 Event Stream。你可以使用任何方式，包括 post，来传输 events，但 Websockets 特别适合这种情形。对我们的 Rails 应用而言，意味着可以使用 ActionCable 来传输。下面是一个典型的 GraphQL subscription 所呈现的样子：</p>

<p><img src="https://cdn.evilmartians.com/front/posts/graphql-on-rails-3-on-the-way-to-perfection/subscriptions-b00176f.gif" alt="https://cdn.evilmartians.com/front/posts/graphql-on-rails-3-on-the-way-to-perfection/subscriptions-b00176f.gif" /></p>

<h2 id="laying-the-cable">Laying the cable</h2>

<p>首先，我们要创建<code>app/graphql/types/subscription_type.rb</code>并注册 subscription，使其在新 item 被添加时触发。</p>

<pre><code class="language-ruby"># app/graphql/types/subscription_type.rb

module Types
  class SubscriptionType &lt; GraphQL::Schema::Object
    field :item_added, Types::ItemType, null: false, description: "An item was added"

    def item_added; end
  end
end
</code></pre>

<p>其次，我们要配置 schema 以使用<code>ActionCableSubscriptions</code>，并能从<code>SubscriptionType</code>中找到可用的 subscriptions：</p>

<pre><code class="language-ruby"># app/graphql/martian_library_schema.rb

class MartianLibrarySchema &lt; GraphQL::Schema
  use GraphQL::Subscriptions::ActionCableSubscriptions

  mutation(Types::MutationType)
  query(Types::QueryType)
  subscription(Types::SubscriptionType)
end
</code></pre>

<p>第三，我们要生成一个 ActionCable channel 来处理已订阅的客户端：</p>

<pre><code class="language-bash">$ rails generate channel GraphqlChannel
</code></pre>

<p>让我们从<a href="https://graphql-ruby.org/api-doc/1.8.13/GraphQL/Subscriptions/ActionCableSubscriptions">文档</a>中借用 channel 的实现代码：</p>

<pre><code class="language-ruby"># app/channels/graphql_channel.rb

class GraphqlChannel &lt; ApplicationCable::Channel
  def subscribed
    @subscription_ids = []
  end

  def execute(data)
    result = execute_query(data)

    payload = {
      result: result.subscription? ? { data: nil } : result.to_h,
      more: result.subscription?
    }

    @subscription_ids &lt;&lt; context[:subscription_id] if result.context[:subscription_id]

    transmit(payload)
  end

  def unsubscribed
    @subscription_ids.each do |sid|
      MartianLibrarySchema.subscriptions.delete_subscription(sid)
    end
  end

  private

  def execute_query(data)
    MartianLibrarySchema.execute(
      query: data["query"],
      context: context,
      variables: data["variables"],
      operation_name: data["operationName"]
    )
  end

  def context
    {
      current_user_id: current_user&amp;.id,
      current_user: current_user,
      channel: self
    }
  end
end
</code></pre>

<p>确认把<code>:channel</code>传给了 context。还有，我们传递了<code>current_user</code>使其在 resolvers 内部可用，跟<code>:current_user_id</code>一样，<a href="https://graphql-ruby.org/subscriptions/triggers.html">可被用来</a>传递范围内的 subscriptions。</p>

<p>现在，我们需要添加在 channel 中获取当前用户的一种方式。以如下方式修改<code>ApplicationCable::Connection</code>：</p>

<pre><code class="language-ruby"># app/channels/application_cable/connection.rb

module ApplicationCable
  class Connection &lt; ActionCable::Connection::Base
    identified_by :current_user

    def connect
      self.current_user = current_user
    end

    private

    def current_user
      token = request.params[:token].to_s
      email = Base64.decode64(token)
      User.find_by(email: email)
    end
  end
end
</code></pre>

<p>触发 event 相当简单：我们应传递驼峰式的字段名作为第一个 argument，options 是第二个 argument，而订阅的更新的 root object 作为第三个 argument。把其加到<code>AddItemMutation</code>：</p>

<pre><code class="language-ruby"># app/graphql/mutations/add_item_mutation.rb

module Mutations
  class AddItemMutation &lt; Mutations::BaseMutation
    argument :attributes, Types::ItemAttributes, required: true

    field :item, Types::ItemType, null: true
    field :errors, [String], null: false

    def resolve(attributes:)
      check_authentication!

      item = Item.new(attributes.merge(user: context[:current_user]))

      if item.save
        MartianLibrarySchema.subscriptions.trigger("itemAdded", {}, item)
        { item: item }
      else
        { errors: item.errors.full_messages }
      end
    end
  end
end
</code></pre>

<p>Argument hash 可以包含 arguments，后者被定义在 subscription 中（其将被作为 resolver arguments 传递）。有一个称为<code>:scope</code>的第四个可选 argument，用来限制会接收到这些更新的用户的范围。</p>

<p>让我们来添加另一个 subscription，这次是更新 items：</p>

<pre><code class="language-ruby"># app/graphql/types/subscription_type.rb

module Types
  class SubscriptionType &lt; GraphQL::Schema::Object
    field :item_added, Types::ItemType, null: false, description: "An item was added"
    field :item_updated, Types::ItemType, null: false, description: "Existing item was updated"

    def item_added; end
    def item_updated; end
  end
end
</code></pre>

<p>下面是在<code>UpdateItemMutation</code>中我们将如何触发这种类型的更新：</p>

<pre><code class="language-ruby"># app/graphql/mutations/update_item_mutation.rb

module Mutations
  class UpdateItemMutation &lt; Mutations::BaseMutation
    argument :id, ID, required: true
    argument :attributes, Types::ItemAttributes, required: true

    field :item, Types::ItemType, null: true
    field :errors, [String], null: false

    def resolve(id:, attributes:)
      check_authentication!

      item = Item.find(id)

      if item.update(attributes.to_h)
        MartianLibrarySchema.subscriptions.trigger("itemUpdated", {}, item)
        { item: item }
      else
        { errors: item.errors.full_messages }
      end
    end
  end
end
</code></pre>

<p>我们应该提到一点，这种 subscriptions 方式是在 <em>graphql-ruby</em> 中为 ActionCable 实现的，会有性能上的瓶颈：大量 Redis 往返，并对每个连接的客户端进行查询重新评估（可在<a href="https://github.com/anycable/anycable-rails/issues/40">这里</a>查看更多有关的深度解析）。</p>

<p><em>对 <a href="https://anycable.io/">AnyCable</a> 用户这已经不再是问题了——从我们为 eBay 项目的工作成果中抽取出来的 <a href="https://github.com/Envek/graphql-anycable">graphql-anycable</a> gem 带来了高效的 GraphQL subscriptions。</em></p>

<h2 id="plugging-in">Plugging in</h2>

<p>要让我们的应用程序发送数据给 ActionCable，需要一些配置。首先，我们要安装一些新 modules 来处理通过 ActionCable 的 Subscriptions：</p>

<pre><code class="language-bash">$ yarn add actioncable graphql-ruby-client
</code></pre>

<p>然后，我们需要添加一些新“魔法”到<code>/app/javascript/utils/apollo.js</code>：</p>

<pre><code class="language-js">// /app/javascript/utils/apollo.js
...
import ActionCable from 'actioncable';
import ActionCableLink from 'graphql-ruby-client/subscriptions/ActionCableLink';
...
const getCableUrl = () =&gt; {
  const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
  const host = window.location.hostname;
  const port = process.env.CABLE_PORT || '3000';
  const authToken = localStorage.getItem('mlToken');
  return `${protocol}//${host}:${port}/cable?token=${authToken}`;
};

const createActionCableLink = () =&gt; {
  const cable = ActionCable.createConsumer(getCableUrl());
  return new ActionCableLink({ cable });
};

const hasSubscriptionOperation = ({ query: { definitions } }) =&gt;
  definitions.some(
    ({ kind, operation }) =&gt;
      kind === 'OperationDefinition' &amp;&amp; operation === 'subscription'
  );


//..
// we need to update our link
  link: ApolloLink.from([
    createErrorLink(),
    createLinkWithToken(),
    ApolloLink.split(
      hasSubscriptionOperation,
      createActionCableLink(),
      createHttpLink(),
    ),
  ]),

//..
</code></pre>

<p>尽管这代码事实上看起来有点可怕，但是思路很简单：</p>

<ul>
  <li>我们在<code>createActionCableLink</code>内为 subscriptions 创建一个新的 Apollo link；</li>
  <li>在 ApolloLink.split 内决定向哪里发送数据；</li>
  <li>如果<code>hasSubscriptionOperation</code>返回 true，operation 就会被发送到<code>actionCableLink</code>。</li>
</ul>

<p>现在我们需要使用<a href="https://github.com/HellSquirrel/create-gql-component">生成器</a>创建一个新组件：</p>

<pre><code class="language-bash">$ npx @hellsquirrel/create-gql-component create /app/javascript/components/Subscription
</code></pre>

<p>让我们来添加 subscription 到<code>operations.graphql</code>：</p>

<pre><code class="language-graphql">#/app/javascript/components/Subscription/operations.graphql
#import '../../fragments/Item.graphql'

subscription ItemSubscription {
  itemAdded {
    ...ItemFragment
    user {
      id
      email
    }
  }

  itemUpdated {
    ...ItemFragment
    user {
      id
      email
    }
  }
}
</code></pre>

<p>毫无新意，对吧？再来创建<code>Subscription</code>组件：</p>

<pre><code class="language-js">
// /app/javascript/components/Subscription/index.js
import React, { useEffect } from 'react';
import { ItemSubscription } from './operations.graphql';

const Subscription = ({ subscribeToMore }) =&gt; {
  useEffect(() =&gt; {
    return subscribeToMore({
      document: ItemSubscription,
      updateQuery: (prev, { subscriptionData }) =&gt; {
        if (!subscriptionData.data) return prev;
        const { itemAdded, itemUpdated } = subscriptionData.data;

        if (itemAdded) {
          const alreadyInList = prev.items.find(e =&gt; e.id === itemAdded.id);
          if (alreadyInList) {
            return prev;
          }

          return { ...prev, items: prev.items.concat([itemAdded]) };
        }

        if (itemUpdated) {
          return {
            ...prev,
            items: prev.items.map(el =&gt;
              el.id === itemUpdated.id ? { ...el, ...itemUpdated } : el
            ),
          };
        }

        return prev;
      },
    });
  }, []);
  return null;
};

export default Subscription;
</code></pre>

<p>又一个 hook！这里是<code>useEffect</code>。它在初始渲染时被调用，并在用户更改时重新运行。</p>

<p>我们要求 hook 来订阅 <code>add</code>和<code>update</code> 的 event streams。当相应事件被触发时我们就添加或更新 items。</p>

<p>最后一步是把<code>Subscription</code>组件添加到<code>Library</code>，在<code>Query</code>组件内到最后一个<code>div</code>的尾部：</p>

<pre><code class="language-js">import Subscription from '../Subscription';
//...
const Library = () =&gt; {
  const [item, setItem] = useState(null);
  return (
    &lt;Query query={LibraryQuery}&gt;
      {({ data, loading, subscribeToMore /* we need subscribe to more arg */}) =&gt; (
        &lt;div&gt;
          // ...
          &lt;Subscription subscribeToMore={subscribeToMore} /&gt;
        &lt;/div&gt;
      )}
    &lt;/Query&gt;
  );
};
//...
</code></pre>

<p><em>react-apollo</em> 库的<code>Query</code>组件提供了特别的函数<code>subscribeToMore</code>，其被<code>Subscription</code>组件所使用。我们把这个函数传递给了<code>Subscription</code>组件。</p>

<p>现在我们可以来测试自己的 subscriptions 了！试着在一个浏览器的 tab 中添加新 item 或者修改已有的——你将会看到所有打开的 tabs 中都会出现变化。</p>

<h2 id="结语">结语</h2>

<p>祝贺你！</p>

<p>这就是我们穿越 Ruby-GraphQL-Apollo 世界的令人激动的冒险之旅的终点了。使用一个小的范例应用，我们实践了所有的基础技术，强调了常见的问题，还介绍了一些高级主题。</p>

<p>这可能是一个具有挑战性的练习，但我们确信你将从中受益。无论如何，你现在都有足够的理论和实践来为自己创建利用上 GraphQL 强大威力的 Rails 应用了！</p>


</div>

<!-- Rating -->

<div class="rating mt-4 mb-4 d-flex align-items-center">
    <strong class="mr-1">Rating:</strong> <div class="rating-holder">
<div class="c-rating c-rating--regular" data-rating-value="5">
  <button>1</button>
  <button>2</button>
  <button>3</button>
  <button>4</button>
  <button>5</button>
</div>
</div>
</div>


<!-- Author Box if enabled from _config.yml -->
<!-- Author Box -->


<div class="d-flex authorbox align-items-center">
    <div class="col-md-2 mr-4 text-center">
        
        <img class="author-thumb" src="/assets/images/avatar.png" alt="Mr.Z">
        
    </div>
    <div class="col-md-10"> 
        <a target="_blank" class="text-dark h4" href="https://xfyuan.github.io">About Mr.Z</a>   <a target="_blank" href="https://twitter.com/apexy" class="btn-sm"><i class="fab fa-twitter"></i></a>        
        <span class="author-description d-block mt-2">A Chinese software engineer living and working in Chengdu. I love Creating the future in digital worlds, big and small.</span>            
    </div>
</div>



<!-- Comments if not disabled with comments: false -->
<!-- Comments
================================================== -->
 
<div class="comments">
    <button class="btn btn-dark show-comments">Load Comments</button>         
    <div id="comments">  
        <h4 class="mb-4">Comments</h4>                 
            <section class="disqus">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'xfyuan'; 
        var disqus_developer = 0;
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = window.location.protocol + '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>
     
    <div class="clearfix"></div>              
    </div>    
</div>       


<!-- Share -->
<div class="share">
    <p>
        Share
    </p>
    <ul>
        <li class="ml-1 mr-1">
            <a target="_blank" href="https://twitter.com/intent/tweet?text=GraphQL on Rails——至臻&url=/2020/11/graphql-on-rails-series-3/" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                <i class="fab fa-twitter"></i>
            </a>
        </li>

        <li class="ml-1 mr-1">
            <a target="_blank" href="https://facebook.com/sharer.php?u=/2020/11/graphql-on-rails-series-3/" onclick="window.open(this.href, 'facebook-share', 'width=550,height=435');return false;">
                <i class="fab fa-facebook-f"></i>
            </a>
        </li>

        <li class="ml-1 mr-1">
            <a target="_blank" href="https://www.linkedin.com/shareArticle?mini=true&url=/2020/11/graphql-on-rails-series-3/" onclick="window.open(this.href, 'width=550,height=435');return false;">
                <i class="fab fa-linkedin-in"></i>
            </a>
        </li>

    </ul>
</div>


<!-- Related Post -->
<!-- Related Posts
================================================== -->
<div class=" related-posts ">  

    
    <h2 class="text-center mb-4">Explore more like this</h2>
    
    
    <div class="d-flex justify-content-center align-items-center">
    
    <!-- Categories -->
    
    
    <a class="smoothscroll badge badge-primary text-capitalize" href="/categories#Programming">Programming</a>                
    
    <a class="smoothscroll badge badge-primary text-capitalize" href="/categories#Translation">Translation</a>                
    

    <!-- Tags -->  
    
                    
    <a class="smoothscroll badge badge-primary text-capitalize" href="/tags#graphql">graphql</a>               
                    
    <a class="smoothscroll badge badge-primary text-capitalize" href="/tags#rails">rails</a>               
                    
    <a class="smoothscroll badge badge-primary text-capitalize" href="/tags#ruby">ruby</a>               
    

    </div>

    
    
    
    <div class="blog-grid-container">
        
        
            
            
        
            
        
            
            <!-- begin post -->


<div class="blog-grid-item">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="/2021/04/hotwire-reactive-rails-with-no-javascript/">
                

                    
                        <img class="img-thumb lazyimg" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAACCAQAAAA3fa6RAAAADklEQVR42mNkAANGCAUAACMAA2w/AMgAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/xfyuan/ossimgs@master/uPic/IMG_20210220_121324.jpg" alt="Hotwire: 没有JavaScript的Reactive Rails">
                    

                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title">
                <a class="text-dark" href="/2021/04/hotwire-reactive-rails-with-no-javascript/">Hotwire: 没有JavaScript的Reactive Rails</a>
                
                <div class="mb-2 mt-2 font-weight-normal">
                <div class="rating-holder">
<div class="c-rating c-rating--regular" data-rating-value="5">
  <button>1</button>
  <button>2</button>
  <button>3</button>
  <button>4</button>
  <button>5</button>
</div>
</div>
                </div>
                
            </h2>
            <h4 class="card-text">本文已获得原作者（Vladimir Dementyev）和 Evil Martians 授权许可进行翻译。原文介绍了 Rails 的最新“魔法”：Hotwire。这也是 Vladimir Dementyev 在 RailsConf 2021 上的演讲内容。
</h4>
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                <span class="meta-footer-thumb">
                
                <img class="author-thumb" src="/assets/images/avatar.png" alt="Mr.Z">
                
                </span>
                <span class="author-meta">
                <span class="post-name"><a target="_blank" href="https://xfyuan.github.io">Mr.Z</a></span> 
                
                <span class="post-date">24 Apr 2021</span>
                </span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>
<!-- end post -->
            
            
            
        
        
        
            
            
        
            
        
            
            <!-- begin post -->


<div class="blog-grid-item">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="/2021/04/the-foundation-of-how-tailwindcss-works/">
                

                    
                        <img class="img-thumb lazyimg" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAACCAQAAAA3fa6RAAAADklEQVR42mNkAANGCAUAACMAA2w/AMgAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/xfyuan/ossimgs@master/uPic/IMG_20210220_115551.jpg" alt="Tailwindcss底层基石的理念">
                    

                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title">
                <a class="text-dark" href="/2021/04/the-foundation-of-how-tailwindcss-works/">Tailwindcss底层基石的理念</a>
                
            </h2>
            <h4 class="card-text">Tailwindcss 从 2019 年开始逐渐在国外的 Web 开发圈子内盛行起来。国内倒是至今仍然不温不火。2020 年的 Ruby China 上过纯中做过一次在项目上使用 tailwindcss 体验的有关演讲。我在 2020 年也写过一篇有关的博客“在 Rails 6 中整合 Stimulus 和 Tailwind CSS”（被前者在演讲中所引用^_^）。
</h4>
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                <span class="meta-footer-thumb">
                
                <img class="author-thumb" src="/assets/images/avatar.png" alt="Mr.Z">
                
                </span>
                <span class="author-meta">
                <span class="post-name"><a target="_blank" href="https://xfyuan.github.io">Mr.Z</a></span> 
                
                <span class="post-date">10 Apr 2021</span>
                </span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>
<!-- end post -->
            
            
            
        
        
        
            
            
        
            
        
            
            <!-- begin post -->


<div class="blog-grid-item">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="/2021/03/hotwire-build-turbo-application/">
                

                    
                        <img class="img-thumb lazyimg" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAACCAQAAAA3fa6RAAAADklEQVR42mNkAANGCAUAACMAA2w/AMgAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/xfyuan/ossimgs@master/uPic/IMG_20210220_133340.jpg" alt="Hotwire之构建Turbo应用">
                    

                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title">
                <a class="text-dark" href="/2021/03/hotwire-build-turbo-application/">Hotwire之构建Turbo应用</a>
                
            </h2>
            <h4 class="card-text">本文是对构建 Turbo 应用的具体描述，原文出自：https://turbo.hotwire.dev/handbook/building。
</h4>
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                <span class="meta-footer-thumb">
                
                <img class="author-thumb" src="/assets/images/avatar.png" alt="Mr.Z">
                
                </span>
                <span class="author-meta">
                <span class="post-name"><a target="_blank" href="https://xfyuan.github.io">Mr.Z</a></span> 
                
                <span class="post-date">26 Mar 2021</span>
                </span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>
<!-- end post -->
            
            
                
        </div>        
</div>

<!-- Review with LD-JSON, adapt it for your needs if you like, but make sure you test the generated HTML source code first: 
https://search.google.com/structured-data/testing-tool/u/0/
================================================== -->

    <script type="application/ld+json">
    {
    "@context": "http://schema.org/",
    "@type": "Review",
    "itemReviewed": {
    "@type": "Thing",
    "name": "GraphQL on Rails——至臻"
    },
    "author": {
    "@type": "Person",
    "name": "Mr.Z"
    },
    "datePublished": "2020-11-28",
    "reviewRating": {
    "@type": "Rating",
    "ratingValue": "5",
    "bestRating": "5"
    }
    }
    </script>

    </div>

    

</div>

<!-- Begin Footer
================================================== -->
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-12 text-center text-lg-left">
                Copyright © 2021 The Tragedy of XY
            </div>
            <div class="col-md-6 col-sm-12 text-center text-lg-right">
                <a target="_blank" href="https://www.wowthemes.net/memoirs-free-jekyll-theme/">Memoirs Jekyll Theme</a>
            </div>
        </div>
    </div>
</footer>
<!-- End Footer
================================================== -->

</div> <!-- /.site-content -->

<!-- Scripts (if you need bootstrap.js, please add it yourself. I didn't use it for performance reasons, it was not needed in this theme)
================================================== -->

<script src="/assets/js/prism.js"></script>

<script src="/assets/js/theme.js"></script>


<script src="/assets/js/lazyload.js"></script>



<script id="dsq-count-scr" src="//xfyuan.disqus.com/count.js"></script>


</body>
</html>
