<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<link rel="icon" href="/assets/images/logo.png">

<title>《Programming Elixir >= 1.6》第五章：匿名函数 | The Tragedy of XY</title>

<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>《Programming Elixir &gt;= 1.6》第五章：匿名函数 | The Tragedy of XY</title>
<meta name="generator" content="Jekyll v4.1.0" />
<meta property="og:title" content="《Programming Elixir &gt;= 1.6》第五章：匿名函数" />
<meta name="author" content="Mr.Z" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="函数是 Elixir 的数据转换基石的重要引擎之一。Elixir 函数又分为匿名函数和具名函数。《Programming Elixir &gt;= 1.6》用整个第五章专门讲述了“匿名函数”的概念，可见其重要性。如果是写过 JavaScript 的朋友，对“匿名函数”的概念一定不陌生。而 Elixir 的“匿名函数”到底怎样，看这一章就能完全了解。" />
<meta property="og:description" content="函数是 Elixir 的数据转换基石的重要引擎之一。Elixir 函数又分为匿名函数和具名函数。《Programming Elixir &gt;= 1.6》用整个第五章专门讲述了“匿名函数”的概念，可见其重要性。如果是写过 JavaScript 的朋友，对“匿名函数”的概念一定不陌生。而 Elixir 的“匿名函数”到底怎样，看这一章就能完全了解。" />
<meta property="og:site_name" content="The Tragedy of XY" />
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xfyuan/ossimgs@master/20200720IMG_20200717_150745.jpg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-07-20T00:00:00+00:00" />
<script type="application/ld+json">
{"dateModified":"2020-07-20T00:00:00+00:00","datePublished":"2020-07-20T00:00:00+00:00","description":"函数是 Elixir 的数据转换基石的重要引擎之一。Elixir 函数又分为匿名函数和具名函数。《Programming Elixir &gt;= 1.6》用整个第五章专门讲述了“匿名函数”的概念，可见其重要性。如果是写过 JavaScript 的朋友，对“匿名函数”的概念一定不陌生。而 Elixir 的“匿名函数”到底怎样，看这一章就能完全了解。","url":"/2020/07/programming-elixir-1-6-chapter-5/","@type":"BlogPosting","image":"https://cdn.jsdelivr.net/gh/xfyuan/ossimgs@master/20200720IMG_20200717_150745.jpg","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"/assets/images/logo.png"},"name":"Mr.Z"},"mainEntityOfPage":{"@type":"WebPage","@id":"/2020/07/programming-elixir-1-6-chapter-5/"},"author":{"@type":"Person","name":"Mr.Z"},"headline":"《Programming Elixir &gt;= 1.6》第五章：匿名函数","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


<link href="/assets/css/prism.css" rel="stylesheet">

<link href="/assets/css/theme.css" rel="stylesheet">

<script src="/assets/js/jquery.min.js"></script>

</head>




<body>
	<!-- defer loading of font and font awesome -->
	<noscript id="deferred-styles">
		<link href="https://fonts.googleapis.com/css?family=Sen:400,700&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	</noscript>

<!-- Begin Sidebar Navigation
================================================== -->

<div class="sidebar">
</div>
<div class="nav-icon">
    <div class="hamburger-bar"></div>
</div>
<div id="blackover-nav" class="blackover"></div>
<nav id="menu">
    <ul>
        <h3>Navigation</h3>
        <li><a href="/">Home</a></li>
        <li><a href="/categories">Categories</a></li>
        <li><a href="/about">About</a></li>
    </ul>
</nav>

<script src="/assets/js/lunr.js"></script>

<style>
    
</style>

<div class="wrap-search">
    <div class="d-flex align-items-center ml-auto">
        <i class="fas fa-search show-search"></i>
        <form class="bd-search ml-3" onSubmit="return lunr_search(document.getElementById('lunrsearch').value);">
            <input type="text" class="form-control bigradius text-small launch-modal-search" id="lunrsearch" name="q" maxlength="255" value="" placeholder="Type and enter..."/>
        </form>
    </div>
</div>

<div id="lunrsearchresults">
    <ul></ul>
</div>

<script src="/assets/js/lunrsearchengine.js"></script>


<!-- End Sidebar Navigation
================================================== -->

<div class="site-content ">

<div class="container">

    <!-- Site Logo/Name
    ================================================== -->

    <a class="navbar-brand" href="/">
        <img src="/assets/images/logo.png" alt="The Tragedy of XY">
    </a>


    <!-- Site Tag
    ================================================== -->
    

    <!-- Content
    ================================================== -->
    <div class="main-content">
        <div class="entry-header">
    <!-- Post Title -->
    <h1 class="posttitle">《Programming Elixir >= 1.6》第五章：匿名函数</h1>
    <!-- Author & Date  Box -->
    
    
    <div class="d-flex align-items-center mt-4">
        <div>
            
            <img class="author-thumb" src="/assets/images/avatar.png" alt="Mr.Z">
            
        </div>            
        <div>
        Written by <a target="_blank" class="text-dark" href="https://xfyuan.github.io">Mr.Z</a> on 
        <span class="post-date"><time class="post-date" datetime="2020-07-20">20 Jul 2020</time></span>           
        
        </div>            
    </div>
    
</div>

<!-- Adsense under title if enabled from _config.yml (change your pub id and slot) -->


<!-- Featured Image -->

<div class="entry-featured-image">
    
    <img class="featured-image lazyimg " src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAACCAQAAAA3fa6RAAAADklEQVR42mNkAANGCAUAACMAA2w/AMgAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/xfyuan/ossimgs@master/20200720IMG_20200717_150745.jpg" alt="《Programming Elixir >= 1.6》第五章：匿名函数">
    
</div>


<!-- Content -->
<!-- Post, Page Content
================================================== -->
<div class="article-post">
    <!-- Toc if any -->
    
    <!-- End Toc -->
    <p>函数是 Elixir 的数据转换基石的重要引擎之一。Elixir 函数又分为匿名函数和具名函数。《Programming Elixir &gt;= 1.6》用整个第五章专门讲述了“匿名函数”的概念，可见其重要性。如果是写过 JavaScript 的朋友，对“匿名函数”的概念一定不陌生。而 Elixir 的“匿名函数”到底怎样，看这一章就能完全了解。</p>

<p><em>【下面是正文】</em></p>

<h2 id="5-anonymous-functions">5. Anonymous Functions</h2>

<p>Elixir 是函数式语言，所以毫不意外函数是一个基础类型。</p>

<p>一个匿名函数使用关键字<code>fn</code>来创建。</p>

<pre><code class="language-elixir">fn
  parameter-list -&gt; body
  parameter-list -&gt; body
end
</code></pre>

<p>可以把<code>fn...end</code>想像成有点像包裹字符串字面量的双引号，只是这里把一个函数而非字符串作为返回值。我们可以把这个返回的函数传递给其他函数，也可以向它传参来运行。</p>

<p>最简单的是，函数有一个参数列表和一个函数体，用<code>-&gt;</code>分隔。</p>

<p>例如，下面定义了一个函数，并把其绑定到变量<code>sum</code>，然后调用它：</p>

<pre><code class="language-elixir">iex&gt; sum = fn (a, b) -&gt; a + b end
#Function&lt;12.17052888 in :erl_eval.expr/5&gt;
iex&gt; sum.(1, 2)
3
</code></pre>

<p>第一行代码创建了一个函数，带两个参数（名为 a 和 b）。函数的实现方法位于<code>-&gt;</code>之后（本例中只是简单把两个参数相加），到关键字<code>end</code>为止。我们把该函数存到变量<code>sum</code>上。</p>

<p>第二行代码使用语句<code>sum.(1, 2)</code>执行了这个函数。点<code>.</code>语法表示调用函数，且传递的参数放在括号中。（你可能注意到了，我们在调用具名函数时并没有使用点语法——这是一个匿名函数和具名函数的差别。）</p>

<p>如果函数不带任何参数，仍需要使用括号来调用它：</p>

<pre><code class="language-elixir">iex&gt; greet = fn -&gt; IO.puts "Hello" end
#Function&lt;12.17052888 in :erl_eval.expr/5&gt;
iex&gt; greet.()
Hello
:ok
</code></pre>

<p>然而，可以在定义函数时不要括号：</p>

<pre><code class="language-elixir">iex&gt; f1 = fn a, b -&gt; a * b end
#Function&lt;12.17052888 in :erl_eval.expr/5&gt;
iex&gt; f1.(5,6)
30
iex&gt; f2 = fn -&gt; 99 end
#Function&lt;12.17052888 in :erl_eval.expr/5&gt;
iex&gt; f2.()
99
</code></pre>

<h3 id="functions-and-pattern-matching">Functions and Pattern Matching</h3>

<p>当我们调用<code>sum.(2, 3)</code>时，很自然会认为是简单地把 2 赋予参数 a、3 赋予参数 b。但是这个词，赋予，应当给我们敲响警钟。Elixir 没有赋值，而是试图把值和模式进行匹配。（这些我们已经在前面的《Pattern Matching》一章中讲过了。）</p>

<p>当我们写下</p>

<pre><code class="language-elixir">a = 2
</code></pre>

<p>Elixir 会通过把 a 绑定到 2 来进行模式匹配。这才是刚才的<code>sum</code>函数被调用时发生的事。如果我们传递 2 和 3作为参数时，Elixir 会试图把传入的参数和定义的参数 a 和 b 进行匹配（这样就绑定 a 为 2以及 b 为 3）。这等同于：</p>

<pre><code class="language-elixir">{a, b} = {2, 3}
</code></pre>

<p>这意味着我们在调用一个函数时可以进行更复杂的模式匹配。例如，下面的函数把一个二元元组中的两个元素颠倒了顺序：</p>

<pre><code class="language-elixir">iex&gt; swap = fn { a, b } -&gt; { b, a } end
#Function&lt;12.17052888 in :erl_eval.expr/5&gt;
iex&gt; swap.( { 6, 8 } )
{8, 6}
</code></pre>

<p>下一节中，我们会看到通过利用模式匹配的威力来达到函数的多种实现方式。</p>

<h3 id="one-function-multiple-bodies">One Function, Multiple Bodies</h3>

<p>单个函数定义允许你定义不同的实现，具体取决于传递的参数的类型和内容。（你无法根据参数的数量进行选择 - 函数定义中每个子句必须具有相同数量的参数。）</p>

<p>最简单的，我们能够使用模式匹配来选择哪个子句被执行。下面的例子中，由于我们知道<code>File.open</code>在成功打开文件时会返回一个首元素为 :ok 的元组，所以我们可以定义一个函数，要么显示打开文件的第一行，要么在文件无法打开时显示一个简单的错误信息。</p>

<pre><code class="language-elixir">iex&gt; handle_open = fn
...&gt; {:ok, file} -&gt; "Read data: #{IO.read(file, :line)}"
...&gt; {_, error} -&gt; "Error: #{:file.format_error(error)}"
...&gt; end
#Function&lt;12.17052888 in :erl_eval.expr/5&gt;
iex&gt; handle_open.(File.open("code/intro/hello.exs"))
"Read data: IO.puts \"Hello, World!\"\n"
iex&gt; handle_open.(File.open("nonexistent"))
"Error: no such file or directory"
</code></pre>

<p>来看一下函数定义的内部。2、3行我们定义了两个单独的函数体，每个都用一个元组作为参数。第一个需要元组的首元素为 :ok，第二个使用特别的变量<code>_</code>（下划线）来匹配任何其他的值作为首元素。</p>

<p>再看第6行，我们调用了该函数，且把使用<code>File.open</code>打开一个已存在文件的结果传递给它。这意味着它接收到的是元组<code>{:ok, file}</code>，这正好匹配了第2行的函数字句。相应地调用<code>IO.read</code>读取该文件的第一行。</p>

<p>接着我们再次调用<code>handle_oepn</code>，这次尝试打开一个不存在文件。返回的元组（<code>{:error, :enoent}</code>）被传递给它，并寻找一个可匹配的子句。第2行会由于首元素不是 :ok 而匹配失败，但下一行能匹配成功。error 恰好能完美契合该子句的代码格式。</p>

<p>留意一下代码的其他部分。第3行我们调用了<code>:file.format_error</code>，<code>:file</code>部分表示了底层 Erlang 的<code>File</code>模块，因此我们能调用其<code>format_error</code>函数。与第6行的<code>File.open</code>调用对比一下，那里的<code>File</code>部分对应的是 Elixir 的内建模块。这是一个 Elixir 代码中使用底层环境（函数）的好例子。很棒的是，你能使用全部现有的 Erlang 库——有成千上万经过了时间检验的代码任你取用。但这也有点复杂了，你在调用时将不得不在 Erlang 的函数和 Elixir 的函数中进行区分。</p>

<p>最后，上例中展示了 Elixir 的<em>字符串插值</em>。在一个字符串中，<code>#{...}</code>的内容会被解析并使用其结果来代替。</p>

<h3 id="functions-can-return-functions">Functions Can Return Functions</h3>

<p>这儿有一些奇怪的代码：</p>

<pre><code class="language-elixir">iex&gt; fun1 = fn -&gt; fn -&gt; "Hello" end end
#Function&lt;12.17052888 in :erl_eval.expr/5&gt;
iex&gt; fun1.()
#Function&lt;12.17052888 in :erl_eval.expr/5&gt;
iex&gt; fun1.().()
"Hello"
</code></pre>

<p>奇怪的地方在于第一行。它很难理解，所以我们把它展开来看。</p>

<pre><code class="language-elixir">fun1 = fn -&gt;
					fn -&gt;
						"Hello"
					end
				end
</code></pre>

<p>变量<code>fun1</code>被绑定到一个函数。这个函数不带参数，其函数体是第二个函数定义。第二个函数也不带参数，返回字符串“Hello”。</p>

<p>当我们调用外层函数（使用<code>fun1.()</code>），它返回内层函数。这个返回值当我们再调用（<code>fun1.().()</code>）时内层函数即被执行，“Hello”被返回。</p>

<p>一般来说我们不会写出类似<code>fun1.().()</code>这样的代码。然而我们可以调用外层函数并绑定结果给一个变量。还可以用括号把内层函数括起来使其不易混淆。</p>

<pre><code class="language-elixir">iex&gt; fun1 = fn -&gt; (fn -&gt; "Hello" end) end
#Function&lt;12.17052888 in :erl_eval.expr/5&gt;
iex&gt; other = fun1.()
#Function&lt;12.17052888 in :erl_eval.expr/5&gt;
iex&gt; other.()
"Hello"
</code></pre>

<h4 id="functions-remember-their-original-environment">Functions Remember Their Original Environment</h4>

<p>让我们更深入地看下嵌套函数。</p>

<pre><code class="language-elixir">iex&gt; greeter = fn name -&gt; (fn -&gt; "Hello #{name}" end) end #Function&lt;12.17052888 in :erl_eval.expr/5&gt;
iex&gt; dave_greeter = greeter.("Dave")
#Function&lt;12.17052888 in :erl_eval.expr/5&gt;
iex&gt; dave_greeter.()
"Hello Dave"
</code></pre>

<p>当我们调用外层函数，其返回内层的函数定义。这时并没有把 name 替换成字符串。然而当我们调用内层函数（<code>dave_greeter.()</code>）时，替换发生了，结果显示出来。</p>

<p>有些奇怪的事情发生了。内层函数使用外层函数的<code>name</code>参数。在<code>greeter.("Dave")</code>执行并返回时，外层函数已经结束，参数已不在定义域了。但是当我们运行内层函数，它又使用了这个参数的值。</p>

<p>这之所以能正常运行是由于在 Elixir 中函数会自动携带变量的绑定，包括其在定义时的域。上面例子中，变量<code>name</code>是在外层函数的域中被绑定。当内层函数定义时，它继承了这个域，且把<code>name</code>相关的绑定一起带上了。这就是闭包——它的域会包含其变量的绑定，并把这些绑定打包成可以保存并在以后使用的东西。</p>

<p>来看看更多的玩意儿。</p>

<h4 id="parameterized-functions">Parameterized Functions</h4>

<p>上一个示例中，外层函数带一个参数，内层函数则没有。现在试试都带参数的情况。</p>

<pre><code class="language-elixir">iex&gt; add_n = fn n -&gt; (fn other -&gt; n + other end) end #Function&lt;12.17052888 in :erl_eval.expr/5&gt;
iex&gt; add_two = add_n.(2)
#Function&lt;12.17052888 in :erl_eval.expr/5&gt;
iex&gt; add_five = add_n.(5)
#Function&lt;12.17052888 in :erl_eval.expr/5&gt;
iex&gt; add_two.(3)
5
iex&gt; add_five.(7)
12
</code></pre>

<p>这里内层函数把其参数<code>other</code>加到外层函数的参数<code>n</code>上。每次调用外层函数，我们传一个值给其参数<code>n</code>，它返回一个函数，这个函数把<code>n</code>和其自己的参数相加。</p>

<h3 id="passing-functions-as-arguments">Passing Functions as Arguments</h3>

<p>函数就是值，所以可以把它们传给其他函数。</p>

<pre><code class="language-elixir">iex&gt; times_2 = fn n -&gt; n * 2 end
#Function&lt;12.17052888 in :erl_eval.expr/5&gt;
iex&gt; apply = fn (fun, value) -&gt; fun.(value) end #Function&lt;12.17052888 in :erl_eval.expr/5&gt;
iex&gt; apply.(times_2, 6)
12
</code></pre>

<p>这里，<code>apply</code>是一个带第二个函数和一个值的函数。它返回的是第二个函数以那个值作为参数运行的结果。</p>

<p>在 Elixir 中，这种函数传递的能力几乎在到处都被漂亮地使用着。例如，内置的<code>Enum</code>模块有一个<code>map</code>函数，使用两个参数：一个集合和一个函数。它返回一个列表，是在那个集合的每个元素上都调用那个函数后的结果。</p>

<pre><code class="language-elixir">iex&gt; list = [1, 3, 5, 7, 9]
[1, 3, 5, 7, 9]
iex&gt; Enum.map list, fn elem -&gt; elem * 2 end
[2, 6, 10, 14, 18]
iex&gt; Enum.map list, fn elem -&gt; elem * elem end
[1, 9, 25, 49, 81]
iex&gt; Enum.map list, fn elem -&gt; elem &gt; 6 end
[false, false, false, true, true]
</code></pre>

<h4 id="pinned-values-and-function-parameters">Pinned Values and Function Parameters</h4>

<p>我们之前看模式匹配时，看到过 pin 操作符（<code>^</code>）允许在模式中使用一个变量的当前值。这种方式也能用在函数参数上。</p>

<pre><code class="language-elixir">defmodule Greeter do
  def for(name, greeting) do
    fn
      (^name) -&gt; "#{greeting} #{name}"
      (_) -&gt; "I don't know you"
    end
  end
end
mr_valim = Greeter.for("José", "Oi!")

IO.puts mr_valim.("José") # =&gt; Oi! José
IO.puts mr_valim.("Dave") # =&gt; I don't know you
</code></pre>

<p>这里，<code>Greeter.for</code>函数返回一个带两个 head 的函数（还记得列表的头和尾吗？）。当第一个参数为传给<code>for</code>的 name 的值时，第一个 head 就能匹配上。</p>

<h4 id="the--notation">The &amp; Notation</h4>

<p>创建短小帮助函数的策略是如此普遍，所以 Elixir 提供了一种快捷方式。我们先来看一下。</p>

<pre><code class="language-elixir">iex&gt; add_one = &amp;(&amp;1 + 1) # same as add_one = fn (n) -&gt; n + 1 end
#Function&lt;6.17052888 in :erl_eval.expr/5&gt;
iex&gt; add_one.(44)
45
iex&gt; square = &amp;(&amp;1 * &amp;1)
#Function&lt;6.17052888 in :erl_eval.expr/5&gt;
iex&gt; square.(8)
64
iex&gt; speak = &amp;(IO.puts(&amp;1))
&amp;IO.puts/1
iex&gt; speak.("Hello")
Hello
:ok
</code></pre>

<p><code>&amp;</code>操作符把其后的表达式转换为一个函数。在表达式内，<code>&amp;1, &amp;2</code>等类似的占位符依次对应第一个、第二个等函数的参数。所以<code>&amp;(&amp;1 + &amp;2)</code>会被转换为<code>fn p1, p2 -&gt; p1 + p2 end</code>。</p>

<p>如果你觉得这种做法很聪明，那我们再来看看上面代码中有<code>speak</code>的那一行。一般来说 Elixir 会生成一个匿名函数，所以<code>&amp;(IO.puts(&amp;1))</code>会变成<code>fn x -&gt; IO.puts(x) end</code>。然而 Elixir 注意到匿名函数的函数体是一个简单具名函数（IO 模块的 puts 函数）的调用，且其参数按正确的顺序对应（意思是，匿名函数的第一个参数就是具名函数的第一个参数，以此类推）。因此 Elixir 就会优化这个匿名函数，用具名函数（<code>IO.puts/1</code>）的一个直接引用来代替它。</p>

<p>要使其正常工作，参数必须保持正确的顺序：</p>

<pre><code class="language-elixir">iex&gt; rnd = &amp;(Float.round(&amp;1, &amp;2))
&amp;Float.round/2
iex&gt; rnd = &amp;(Float.round(&amp;2, &amp;1))
#Function&lt;12.17052888 in :erl_eval.expr/5&gt;
</code></pre>

<p>当用这种方式定义函数时，你可能会看到对 Erlang 的引用蹦出来，这是因为 Elixir 运行在 Erlang VM 上的缘故。当你尝试更多如<code>&amp;abs(&amp;1)</code>的东西时，可以看到这种行为的更多体现。这里 Elixir 把对于 abs 函数的使用直接映射到底层的 Erlang 库，返回<code>&amp;:erlang.abs/1</code>。</p>

<p>因为<code>[]</code>和<code>{}</code>在 Elixir 中都是操作符，列表和元组的字面量也能被转换为函数。下面这个函数用来返回一个元组，其元素包含两个整数相除后的商和余数：</p>

<pre><code class="language-elixir">iex&gt; divrem = &amp;{ div(&amp;1,&amp;2), rem(&amp;1,&amp;2) } #Function&lt;12.17052888 in :erl_eval.expr/5&gt;
iex&gt; divrem.(13, 5)
{2, 3}
</code></pre>

<p>最后，<code>&amp;</code>操作符也可用于字符串（或类似字符串）的字面量：</p>

<pre><code class="language-elixir">iex&gt; s = &amp;"bacon and #{&amp;1}"
#Function&lt;6.99386804/1 in :erl_eval.expr/5&gt;
iex&gt; s.("custard")
"bacon and custard"

iex&gt; match_end = &amp;~r/.*#{&amp;1}$/
#Function&lt;6.99386804/1 in :erl_eval.expr/5&gt;
iex&gt; "cat" =~ match_end.("t")
true
iex&gt; "cat" =~ match_end.("!")
false
</code></pre>

<p>还有第二种<code>&amp;</code>函数捕获操作符的使用方式。你能传给它一个已有函数的名称和元数（参数的个数），它返回的匿名函数会调用这个函数。传递给匿名函数的参数会依次传给这个具名函数。我们已经看到过了：当你在 iex 中输入<code>&amp;(IO.puts(&amp;1))</code>，看到显示的结果是<code>&amp;IO.puts/1</code>。这里<code>puts</code>是 IO 模块的函数，带一个参数。在 Elixir 中对其的命名方式为<code>IO.puts/1</code>。当把<code>&amp;</code>放在它的前面时，我们是把它封装为了一个函数。再看看其他的例子：</p>

<pre><code class="language-elixir">iex&gt; l = &amp;length/1
&amp;:erlang.length/1
iex&gt; l.([1,3,5,7])
4

iex&gt; len = &amp;Enum.count/1
&amp;Enum.count/1
iex&gt; len.([1,2,3,4])
4

iex&gt; m = &amp;Kernel.min/2 # This is an alias for the Erlang function
&amp;:erlang.min/2
iex&gt; m.(99,88)
88
</code></pre>

<p>这种方式对于我们自己写的具名函数也是适用的（尽管我们还没有讲怎样写具名函数）。</p>

<p><code>&amp;</code>快捷方式为我们提供了一种绝妙的方式来把函数传递给其他函数。</p>

<pre><code class="language-elixir">iex&gt; Enum.map [1,2,3,4], &amp;(&amp;1 + 1)
[2, 3, 4, 5]
iex&gt; Enum.map [1,2,3,4], &amp;(&amp;1 * &amp;1)
[1, 4, 9, 16]
iex&gt; Enum.map [1,2,3,4], &amp;(&amp;1 &lt; 3)
[true, true, false, false]
</code></pre>

<h3 id="functions-are-the-core">Functions Are the Core</h3>

<p>本书开头，我们说过编程的基石是数据的转换。函数是 提供这种转换的微小引擎。它们居于 Elixir 的最中心。</p>

<p>至此我们已经领略了匿名函数——尽管我们能把它们和变量绑定，但这些函数自己并没有名称。Elixir 也有具名函数。下一章就会讲到它们。</p>

</div>

<!-- Rating -->


<!-- Author Box if enabled from _config.yml -->
<!-- Author Box -->


<div class="d-flex authorbox align-items-center">
    <div class="col-md-2 mr-4 text-center">
        
        <img class="author-thumb" src="/assets/images/avatar.png" alt="Mr.Z">
        
    </div>
    <div class="col-md-10"> 
        <a target="_blank" class="text-dark h4" href="https://xfyuan.github.io">About Mr.Z</a>   <a target="_blank" href="https://twitter.com/apexy" class="btn-sm"><i class="fab fa-twitter"></i></a>        
        <span class="author-description d-block mt-2">A Chinese software engineer living and working in Chengdu. I love Creating the future in digital worlds, big and small.</span>            
    </div>
</div>



<!-- Comments if not disabled with comments: false -->
<!-- Comments
================================================== -->
 
<div class="comments">
    <button class="btn btn-dark show-comments">Load Comments</button>         
    <div id="comments">  
        <h4 class="mb-4">Comments</h4>                 
            <section class="disqus">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'xfyuan'; 
        var disqus_developer = 0;
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = window.location.protocol + '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>
     
    <div class="clearfix"></div>              
    </div>    
</div>       


<!-- Share -->
<div class="share">
    <p>
        Share
    </p>
    <ul>
        <li class="ml-1 mr-1">
            <a target="_blank" href="https://twitter.com/intent/tweet?text=《Programming Elixir >= 1.6》第五章：匿名函数&url=/2020/07/programming-elixir-1-6-chapter-5/" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                <i class="fab fa-twitter"></i>
            </a>
        </li>

        <li class="ml-1 mr-1">
            <a target="_blank" href="https://facebook.com/sharer.php?u=/2020/07/programming-elixir-1-6-chapter-5/" onclick="window.open(this.href, 'facebook-share', 'width=550,height=435');return false;">
                <i class="fab fa-facebook-f"></i>
            </a>
        </li>

        <li class="ml-1 mr-1">
            <a target="_blank" href="https://www.linkedin.com/shareArticle?mini=true&url=/2020/07/programming-elixir-1-6-chapter-5/" onclick="window.open(this.href, 'width=550,height=435');return false;">
                <i class="fab fa-linkedin-in"></i>
            </a>
        </li>

    </ul>
</div>


<!-- Related Post -->
<!-- Related Posts
================================================== -->
<div class=" related-posts ">  

    
    <h2 class="text-center mb-4">Explore more like this</h2>
    
    
    <div class="d-flex justify-content-center align-items-center">
    
    <!-- Categories -->
    
    
    <a class="smoothscroll badge badge-primary text-capitalize" href="/categories#Programming">Programming</a>                
    
    <a class="smoothscroll badge badge-primary text-capitalize" href="/categories#Translation">Translation</a>                
    

    <!-- Tags -->  
    
                    
    <a class="smoothscroll badge badge-primary text-capitalize" href="/tags#elixir">elixir</a>               
    

    </div>

    
    
    
    <div class="blog-grid-container">
        
        
            
            
        
            
        
            
            <!-- begin post -->


<div class="blog-grid-item">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="/2021/04/hotwire-reactive-rails-with-no-javascript/">
                

                    
                        <img class="img-thumb lazyimg" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAACCAQAAAA3fa6RAAAADklEQVR42mNkAANGCAUAACMAA2w/AMgAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/xfyuan/ossimgs@master/uPic/IMG_20210220_121324.jpg" alt="Hotwire: 没有JavaScript的Reactive Rails">
                    

                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title">
                <a class="text-dark" href="/2021/04/hotwire-reactive-rails-with-no-javascript/">Hotwire: 没有JavaScript的Reactive Rails</a>
                
                <div class="mb-2 mt-2 font-weight-normal">
                <div class="rating-holder">
<div class="c-rating c-rating--regular" data-rating-value="5">
  <button>1</button>
  <button>2</button>
  <button>3</button>
  <button>4</button>
  <button>5</button>
</div>
</div>
                </div>
                
            </h2>
            <h4 class="card-text">本文已获得原作者（Vladimir Dementyev）和 Evil Martians 授权许可进行翻译。原文介绍了 Rails 的最新“魔法”：Hotwire。这也是 Vladimir Dementyev 在 RailsConf 2021 上的演讲内容。
</h4>
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                <span class="meta-footer-thumb">
                
                <img class="author-thumb" src="/assets/images/avatar.png" alt="Mr.Z">
                
                </span>
                <span class="author-meta">
                <span class="post-name"><a target="_blank" href="https://xfyuan.github.io">Mr.Z</a></span> 
                
                <span class="post-date">24 Apr 2021</span>
                </span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>
<!-- end post -->
            
            
            
        
        
        
            
            
        
            
        
            
            <!-- begin post -->


<div class="blog-grid-item">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="/2021/04/the-foundation-of-how-tailwindcss-works/">
                

                    
                        <img class="img-thumb lazyimg" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAACCAQAAAA3fa6RAAAADklEQVR42mNkAANGCAUAACMAA2w/AMgAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/xfyuan/ossimgs@master/uPic/IMG_20210220_115551.jpg" alt="Tailwindcss底层基石的理念">
                    

                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title">
                <a class="text-dark" href="/2021/04/the-foundation-of-how-tailwindcss-works/">Tailwindcss底层基石的理念</a>
                
            </h2>
            <h4 class="card-text">Tailwindcss 从 2019 年开始逐渐在国外的 Web 开发圈子内盛行起来。国内倒是至今仍然不温不火。2020 年的 Ruby China 上过纯中做过一次在项目上使用 tailwindcss 体验的有关演讲。我在 2020 年也写过一篇有关的博客“在 Rails 6 中整合 Stimulus 和 Tailwind CSS”（被前者在演讲中所引用^_^）。
</h4>
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                <span class="meta-footer-thumb">
                
                <img class="author-thumb" src="/assets/images/avatar.png" alt="Mr.Z">
                
                </span>
                <span class="author-meta">
                <span class="post-name"><a target="_blank" href="https://xfyuan.github.io">Mr.Z</a></span> 
                
                <span class="post-date">10 Apr 2021</span>
                </span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>
<!-- end post -->
            
            
            
        
        
        
            
            
        
            
        
            
            <!-- begin post -->


<div class="blog-grid-item">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="/2021/03/hotwire-build-turbo-application/">
                

                    
                        <img class="img-thumb lazyimg" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAACCAQAAAA3fa6RAAAADklEQVR42mNkAANGCAUAACMAA2w/AMgAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/xfyuan/ossimgs@master/uPic/IMG_20210220_133340.jpg" alt="Hotwire之构建Turbo应用">
                    

                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title">
                <a class="text-dark" href="/2021/03/hotwire-build-turbo-application/">Hotwire之构建Turbo应用</a>
                
            </h2>
            <h4 class="card-text">本文是对构建 Turbo 应用的具体描述，原文出自：https://turbo.hotwire.dev/handbook/building。
</h4>
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                <span class="meta-footer-thumb">
                
                <img class="author-thumb" src="/assets/images/avatar.png" alt="Mr.Z">
                
                </span>
                <span class="author-meta">
                <span class="post-name"><a target="_blank" href="https://xfyuan.github.io">Mr.Z</a></span> 
                
                <span class="post-date">26 Mar 2021</span>
                </span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>
<!-- end post -->
            
            
                
        </div>        
</div>

<!-- Review with LD-JSON, adapt it for your needs if you like, but make sure you test the generated HTML source code first: 
https://search.google.com/structured-data/testing-tool/u/0/
================================================== -->

    </div>

    

</div>

<!-- Begin Footer
================================================== -->
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-12 text-center text-lg-left">
                Copyright © 2021 The Tragedy of XY
            </div>
            <div class="col-md-6 col-sm-12 text-center text-lg-right">
                <a target="_blank" href="https://www.wowthemes.net/memoirs-free-jekyll-theme/">Memoirs Jekyll Theme</a>
            </div>
        </div>
    </div>
</footer>
<!-- End Footer
================================================== -->

</div> <!-- /.site-content -->

<!-- Scripts (if you need bootstrap.js, please add it yourself. I didn't use it for performance reasons, it was not needed in this theme)
================================================== -->

<script src="/assets/js/prism.js"></script>

<script src="/assets/js/theme.js"></script>


<script src="/assets/js/lazyload.js"></script>



<script id="dsq-count-scr" src="//xfyuan.disqus.com/count.js"></script>


</body>
</html>
